<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>微信小程序的理解</title>
      <link href="2022/02/26/wei-xin-xiao-cheng-xu-de-li-jie/"/>
      <url>2022/02/26/wei-xin-xiao-cheng-xu-de-li-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="微信小程序的理解"><a href="#微信小程序的理解" class="headerlink" title="微信小程序的理解"></a>微信小程序的理解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我已经很久没有更新过文章了，其中有很大大一部分都和微信小程序有关，通过寒假，对微信小程序有了一些理解和看法，并且组队参加了一个有关微信小程序的互联网+的创新比赛，为了做足工作，把之前已经接近一年半多时间没有用过的<code>html</code>,<code>vue</code>等知识捡了回来。其次，为了更好更快的理解开发微信小程序，特别将 <a href="https://kuangtant.gitee.io/">https://kuangtant.gitee.io</a> ，也就是本文官网，开发改造了一下，未来不久，将会上线<code>Kuangtant for Wechat Mini Program</code>小程序，目前仍然还在测试阶段，可能很快就会上线和大家见面。（之所以这么慢，另一个原因是，互联网<code>＋</code>的小程序与之同步开发），下面讲讲一些关于这两款小程序开发，我的理解，和一些坑。</p><h2 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h2><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>学习新的知识，一般来说，必不可少的就是有关的文档了，初识小程序，一定离不开的是 微信小程序开发文档 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/">微信开放文档 </a>，有了文档，就可以在微信小程序领域畅通无阻，其次，为了提高开发时的效率，肯定离不开的是微信小程序前端开源UI框架还有它的文档，常见的就是 <code>WeUi</code>,<code>vant app</code>,<code>colorUI</code>等，并且阅读他们的文档，可以轻松绘制UI界面</p><h3 id="上手-1"><a href="#上手-1" class="headerlink" title="上手"></a>上手</h3><p>微信小程序的无非是从了解结构开始，一个微信小程序简单来说，无非就是包括<code>app.json</code>,<code>app.js</code>,<code>app.wxss</code>还有在page文件夹下的每一页面的<code>js</code>,<code>json</code>,<code>wxml</code>,<code>wxss</code>文件，其它的比较常用的就是项目配置文件，比如<code>project.config.json</code>等</p><p>微信小程序和前端浏览器网页也开发差不多，主要的区别在微信小程序重写了<code>vue</code>的运行方法，<code>wxml</code>不支持很多的<code>html</code>标签，仅支持一些比如<code>text</code>,<code>view</code>等标签</p><p>在微信小程序里面是，流程大概是先启动<code>app.js</code>里面的<code>App()</code>方法，每一页的<code>app.js</code>里面就是<code>Page()</code>方法，自然从里面的<code>onLoad</code>方法开始，然后依次调用各种方法，但是由于微信小程序没有提供<code>dom</code>进行操作，每次更新页面内容就必须使用<code>setData</code>方法，更改数据。页面开始之前，和vue一样，先得初始一些<code>data:&#123;key:&quot;vlule&quot;&#125;</code></p><p>微信小程序为了更好的显示内容，微信小程序提供了<code>wx:for</code> , <code>wx:if</code> , <code>wx:key</code>等节点，来显示数据 </p><h3 id="上手一般的问题"><a href="#上手一般的问题" class="headerlink" title="上手一般的问题"></a>上手一般的问题</h3><h4 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h4><p>微信原生的提供的是<code>bindtap</code>,比如，我开发过程中的一个例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">van-button</span> <span class="attr">size</span>=<span class="string">&quot;mini&quot;</span> <span class="attr">data-selectedId</span>=<span class="string">&quot;&#123;&#123;item&#125;&#125;&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;correctInfo&quot;</span> <span class="attr">round</span> <span class="attr">type</span>=<span class="string">&quot;info&quot;</span>&gt;</span>修改信息<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">correctInfo</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> d = e.currentTarget.dataset.selectedid;</span><br><span class="line">    <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">      goodsname: d.commodityName,</span><br><span class="line">      goodsdesc: d.commodityDetail,</span><br><span class="line">      goodsnum: d.commodityQuantity,</span><br><span class="line">      goodsprice: d.commodityPrice,</span><br><span class="line">      choicheId:d.id,</span><br><span class="line">      fileList: [],</span><br><span class="line">      upgoods: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.iWillSell(&#123;</span><br><span class="line">      upgoods: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="最快解析html的方法"><a href="#最快解析html的方法" class="headerlink" title="最快解析html的方法"></a>最快解析html的方法</h4><p>在微信小程序解析html标签不是一件容易的事，一般可以参照xml的解析方法，解析dom,但是最后发现，解析读取html标签的方式，在微信小程序里最好的方法是正则表达式，有关复习正则的时候那叫一个痛苦，就不多说，具体就按照，下面代码改编</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">regx</span>(<span class="params">res, my_reg</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data = [];</span><br><span class="line">    my_reg.lastIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> tmp_reg;</span><br><span class="line">    <span class="keyword">while</span> ((tmp_reg = my_reg.exec(res)) != <span class="literal">null</span>) &#123;</span><br><span class="line">      data.push(tmp_reg[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用的时候按照一般数组格式，返回正则匹配到的数组</span></span><br><span class="line"><span class="built_in">this</span>.regx(res,<span class="regexp">/A([\s\S]*?)B/gmi</span>);</span><br></pre></td></tr></table></figure><p>返回的是A-B的所有内容</p><h4 id="展示html的内容"><a href="#展示html的内容" class="headerlink" title="展示html的内容"></a>展示html的内容</h4><p>现在解析html再显示在页面就必须使用一些插件，比如wxPrase.js但是，对于代码高亮等需求就必须自己拓展，改变代码，不太好实现，并且不支持插件拓展，还有一个问题，该插件的开发作者已经对该项目停止维护了，为了更好地解决用户需求，建议使用mp-html.js来实现，它的好处就不言而喻，在此提供以下两个项目的位置</p><blockquote><p>mp-html: 小程序富文本组件，支持渲染和编辑 html，支持在微信、QQ、百度、支付宝、头条和 uni-app 平台使用<a href="https://gitee.com/jin-yufeng/mp-html/">https://gitee.com/jin-yufeng/mp-html/ </a></p><p>wxParse:<a href="https://github.com/icindy/wxParse">https://github.com/icindy/wxParse</a></p></blockquote><h4 id="有关前端与后端token验证"><a href="#有关前端与后端token验证" class="headerlink" title="有关前端与后端token验证"></a>有关前端与后端token验证</h4><p>设置了token的一般应该是放在header里面，由于第一次，姿势不对，我和后端多次交涉，最后有很大一部分的问题，实际写法应该如下</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">header: &#123;</span><br><span class="line">        Authorization: &quot;Bearer &quot; + app.globalData.token</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>如此一来，后端的解析完美通过</p><h4 id="有关微信登录"><a href="#有关微信登录" class="headerlink" title="有关微信登录"></a>有关微信登录</h4><p>说到这，就必须说说，登录流程，必须先调用<code>wx.login</code>获得code上传到服务器，让服务器与微信服务端互交，然后使用获取<code>sessionId</code>,用于后面的业务，<code>wx.getUserProfile</code>弹出用户授权窗口，用于登录信息，唯一我踩得最深的坑，我就是将<code>wx.getUserProfile</code>写入了<code>wx.login</code>的<code>success</code>方法里面，一直请求不成功，过了很久，最后发现，<code>wx.getUserProfile</code>只能写在按钮点击事件里面进行交互，不然就会像我一样，一直调试，一直<code>fail</code></p><p>所以，最有效的登录逻辑，就是，在打开用户登录页面，首先调用<code>wx.login</code>，最后在页面上写一个引导用户登录的按钮，用来调用<code>wx.getUserProfile</code></p><h4 id="文件按序上传"><a href="#文件按序上传" class="headerlink" title="文件按序上传"></a>文件按序上传</h4><p>对于微信小程序的文件上传，最让人吐槽的是文件上传，调用 <code>wx.uploadFile</code>,每一次只能上传一个文件，多文件上传就必须多次调用该接口方法，依次文件上传就最好使用递归上传法，比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">upfile</span>(<span class="params">file, count</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="built_in">this</span>;</span><br><span class="line">    wx.uploadFile(&#123;</span><br><span class="line">      filePath: file[count],</span><br><span class="line">      name: <span class="string">&#x27;file&#x27;</span>,</span><br><span class="line">      url: <span class="built_in">this</span>.data.host + <span class="string">&quot;/commodity/insert/upload&quot;</span>,</span><br><span class="line">      header: &#123;</span><br><span class="line">        Authorization: <span class="string">&quot;Bearer &quot;</span> + app.globalData.token</span><br><span class="line">      &#125;,</span><br><span class="line">      method: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">      success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> res = <span class="built_in">JSON</span>.parse(res.data);</span><br><span class="line">        <span class="keyword">if</span> (res.succeed) &#123;</span><br><span class="line">          that.setData(&#123;</span><br><span class="line">            upedfile: [...that.data.upedfile, res.data]</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Toast(res.message + res.code);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      fail: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        Toast(<span class="string">&quot;图片上传失败&quot;</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      complete: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == file.length - <span class="number">1</span>) &#123;</span><br><span class="line">          that.upData();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          that.upfile(file, count + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//以上只是参考，具体按照自己的需求实现</span></span><br><span class="line">upfile(fileList,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="请求链接参数后端没收到，不齐全"><a href="#请求链接参数后端没收到，不齐全" class="headerlink" title="请求链接参数后端没收到，不齐全"></a>请求链接参数后端没收到，不齐全</h4><p>有这个问题，可能使用了get方法，出现这样的情况</p><p>在其他http测试接口没问题，在微信小程序测试就有如上问题，就不妨将后端的get方法改为post请求，原因是url长度在微信小程序的长度有限制，不适合请求过长的url</p>]]></content>
      
      
      
        <tags>
            
            <tag> 微信 </tag>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打造Android最简单优雅的Linux面板</title>
      <link href="2022/01/14/da-zao-android-zui-jian-dan-you-ya-de-linux-mian-ban/"/>
      <url>2022/01/14/da-zao-android-zui-jian-dan-you-ya-de-linux-mian-ban/</url>
      
        <content type="html"><![CDATA[<h1 id="打造Android最简单优雅的Linux面板"><a href="#打造Android最简单优雅的Linux面板" class="headerlink" title="打造Android最简单优雅的Linux面板"></a>打造Android最简单优雅的Linux面板</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>都知道，Android是基于Linux，但在Android平台上，想要运行Linux的应用也不是那么容易，也没有什么方便的终端，想要使用手机办公，不容易，本文就来讲讲基于强大的Termux终端是如何实现Linux的，并且运行一些软件的，如VS Code,WPS,QQ….,话不多说，教程开始</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>要开始工作肯定需要一个强大的工具，那么，Termux便出现了，它是Android平台的一款超级终端APP,在国内，有很多应用市场都提供它的下载，比如，酷安app等，但是要想在国内安装并正常使用，必须下载F-droid下载源的</p><blockquote><p>Termux下载 <a href="https://f-droid.org/en/packages/com.termux/">https://f-droid.org/en/packages/com.termux/</a></p></blockquote><p><img src="image-20220110170312649.png" alt="image-20220110170312649"></p><p>打开下载链接，下拉到下面，找到<code>Download APK</code>点击下载就好</p><p>下载好了，正常安装即可</p><h2 id="起始"><a href="#起始" class="headerlink" title="起始"></a>起始</h2><p>打开Termux，它会自动的进行一些操作，等待完成就好了，下面开始高级操作，安装Linux只需要一行最简单的命令（没有之一）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/mo2/linux/raw/2/2)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>它的原理就是，开源项目 <a href="https://gitee.com/mo2/linux">Tmoe-linux</a></p><blockquote><p><a href="https://gitee.com/mo2/linux:%E5%9C%A8%F0%9F%93%B1Android">https://gitee.com/mo2/linux:在📱Android</a> termux和💻WSL上跨CPU架构运行GNU/Linux容器和桌面环境，便捷配置vnc,xserver和xrdp等远程桌面服务以及音频服务🎵。</p></blockquote><h2 id="系列操作"><a href="#系列操作" class="headerlink" title="系列操作"></a>系列操作</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>运行起始的代码，可能会得到这样的提示<img src="image-20220114153935919.png" alt="image-20220114153935919"></p><p>正常的话，回车就ok,</p><p>第一次使用的话会让你选择语言，可以通过上下的移动选择选择项，回车就是确定，也可以手触</p><p><img src="image-20220114154226050.png" alt="image-20220114154226050"></p><p>这里，我选择中文简体，然后就可以点OK，就来到了下一步，选择运行的方式的菜单</p><p><img src="image-20220114154441941.png" alt="image-20220114154441941"></p><p>由于大多数的android都是没有root过的，所以直接选择第一项<code>proot容器</code>，第一次使用会克隆这个项目到本地，才能继续使用，并且过程中可能会提醒更换下载源，按照默认的即可</p><p><img src="image-20220114154957994.png" alt="image-20220114154957994"></p><p>后面可能会选择一些选项，回车按照默认的就行</p><p><img src="image-20220114155234790.png" alt="image-20220114155234790"></p><p>修改完成的截图如图</p><p><img src="image-20220114155354979.png" alt="换源完成"></p><p>最后系统自动下载一些依赖就OK了</p><p><img src="image-20220114155615806.png" alt="image-20220114155615806"></p><p>以上的操作就是第一步，安装依赖</p><h3 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h3><p>下面我们需要重新执行一下，起始的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/mo2/linux/raw/2/2)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>回到了选择容器的地方</p><p><img src="image-20220114154441941.png" alt="image-20220114154441941"></p><p>这次依然选择proot容器</p><p>会提示选择终端配色，如图，按照个人的喜好选择就可以了（我这里选择neon）</p><p><img src="image-20220114160444986.png" alt="image-20220114160444986"></p><p>下面是选择终端的字体，同样，按照自己的喜好选择，不建议跳过（我这里选择<code>Inconsolata-go(粗)</code>）</p><p><img src="image-20220114160724229.png" alt="image-20220114160724229"></p><p>后面会提示是否修改Termux下面默认的小键盘，可以按照自己的喜好，默认是现在看到的这样</p><p><img src="image-20220114161102924.png" alt="image-20220114161102924"></p><p>修改后是这样</p><p><img src="image-20220114161318814.png" alt="image-20220114161318814"></p><p>看喜好吧，我这里就不改了</p><p>接下来就是选择DNS,其实都可以，我这里选择第6个Tuna吧</p><p><img src="image-20220114161622155.png" alt="image-20220114161622155"></p><p>选择是否启用一言（凭喜好，我这里就开启吧）</p><p><img src="image-20220114161734940.png" alt="image-20220114161734940"></p><p>设置时区，在中国，北京时间，时区是东八区，所以确定就可以了</p><p><img src="image-20220114161948804.png" alt="image-20220114161948804"></p><p>下面大体上设置完成，就可以阅读一下用户协议，回车同意就可以继续使用了</p><p><img src="image-20220114162210840.png" alt="image-20220114162210840"></p><h3 id="新增proot容器"><a href="#新增proot容器" class="headerlink" title="新增proot容器"></a>新增proot容器</h3><p>这时，可能由于你操作系统的架构而出现两种选择，其中一种是amd64的，android手机一般是arm64</p><p>由于我为了方便演示，使用了WSA(windows subsystem for android),所以界面会是amd64下图所示</p><p><img src="image-20220114163129947.png" alt="amd"></p><p>如果是android手机，可能会是arm64这样</p><p><img src="image-20220114163549466.png" alt="arm64"></p><p>这里可以选择一种容器进行运行，建议选择与自己系统架构相同的运行，也可以跨架构运行，不过效率有点偏低</p><p>所以就直接选择第一个，默认的发行版列表，下一步就可以选择构建一个自己熟悉的容器（以第一个为例）</p><p><img src="image-20220114164040876.png" alt="image-20220114164040876"></p><p>下面就可以选择自己喜欢的界面（我这里就默认第一个）</p><p><img src="image-20220114164313668.png" alt="image-20220114164313668"></p><p>下面就继续安装一个distribution,按照喜好选择，我这里选择<code>kali-rolling</code></p><p><img src="image-20220114164603005.png" alt="kali-rolling"></p><p>就这样，容器就构建好了，下面就可以启动我们新建的kali-xfce-amd64的容器</p><p><img src="image-20220114164824328.png" alt="image-20220114164824328"></p><p>第一次启动，会选择网络节点（我选第一个Tmoe默认）</p><p><img src="image-20220114165011423.png" alt="image-20220114165011423"></p><p>选择节点，下载你选择的容器镜像（回车一下）</p><p><img src="image-20220114165146084.png" alt="image-20220114165146084"></p><p>下面就是漫长的等待下载,下载过程中会出现一些错误，不用管，系统会自己处理</p><p><img src="image-20220114165502319.png" alt="image-20220114165502319"></p><p>等待下载完成以后，会有系统自动安装一些依赖，优化，最后完成后，会提示是否新建一个sudo的用户，是在这个虚拟的容器里面的sodo用户，并不是termux的</p><p><img src="image-20220114170731727.png" alt="image-20220114170731727"></p><p>演示就新建一个sudo的user吧</p><p><img src="image-20220114170758976.png" alt="image-20220114170758976"></p><p>然后是sudo的密码</p><p><img src="image-20220114170917949.png" alt="image-20220114170917949"></p><p>第一次设置，会询问是否将新建的sudo用户设置为默认用户（权凭自己，我这里否）</p><p><img src="image-20220114171100213.png" alt="image-20220114171100213"></p><p>后面会询问是否删除<code>~/zsh.sh &amp; ~zsh-i.sh</code>的提示，这里我选择删除</p><p><img src="image-20220114171311521.png" alt="image-20220114171311521"></p><p>下面会询问是否安装tmoe tools的工具，方便安装软件和管理，这里就选择安装吧</p><p><img src="image-20220114171453767.png" alt="image-20220114171453767"></p><p>后面是一个头像，arm64是使用的QQ头像，amd64就是默认的头像（这里就yes了）</p><p><img src="image-20220114171634715.png" alt="image-20220114171634715"></p><p>下面就可以设置VNC的访问密码了</p><p><img src="image-20220114171816175.png" alt="image-20220114171816175"></p><p>选择端口（5902或5903都可以）</p><p>下面就是一些开启VNC远程服务的命令</p><p><img src="image-20220114171939743.png" alt="image-20220114171939743"></p><p>执行完成以后一般会来到我们的tmoe-tools的主面板<img src="image-20220114172331006.png" alt="image-20220114172331006"></p><p>这里可以安装一些感兴趣的软件，浏览器等等，到这里，就算Linux安装完成了，我们先安装一个GUI的图形界面，方便后面vnc启动</p><p><img src="image-20220114181055161.png" alt="image-20220114181055161"></p><p>在Termux里面，没有root只能选择第一个proot_DE,下面选择一个我们喜欢的GUI安装，就安装第一个吧xfce</p><p><img src="image-20220114181221657.png" alt="image-20220114181221657"></p><p>下面就是一路回车，安装想要的东西。</p><p>安装好了就可以退出，就退出了tmoe-tools的面板，来到了我们希望的地方</p><p><img src="image-20220114172830546.png" alt="image-20220114172830546"></p><p>退出这里，可以使用exit</p><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>如果想进入termux启动安装的linux有两种方法，一般使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmoe m</span><br></pre></td></tr></table></figure><p>启动tmoe-tools，</p><p><img src="image-20220114154441941.png" alt="tmoe-manager"></p><p>进入proot容器，选择第二个已经安装的容器列表</p><p><img src="image-20220114163129947.png" alt="amd"></p><p>就可以看到已经安装的linux的列表</p><p><img src="image-20220114173701496.png" alt="image-20220114173701496"></p><p>可以进入，启动容器</p><blockquote><p>如果无法启动，或者有异常，可以在tome-tools的页面，选择<code>FAQ常见问题</code>，里面解决<img src="image-20220114174526307.png" alt="image-20220114174526307"></p></blockquote><h3 id="VNC界面"><a href="#VNC界面" class="headerlink" title="VNC界面"></a>VNC界面</h3><p>在Linux界面，输入<code>startvnc</code>,就可以看到VNC的地址</p><p><img src="image-20220114230340635.png" alt="image-20220114230340635"></p><p>在手机或电脑上下载VNC Viewer，输入刚才的局域网地址，就可以浏览GUI的图形化界面了</p><p><img src="image-20220114231055086.png" alt="image-20220114231055086"></p><p>可以通过tmoe m的工具安装一些实用的软件，比如（QQ,WPS,Android studio)<img src="image-20220114231731111.png" alt="image-20220114231731111"></p><p>选择第二个，Software center,就可以为所欲为，安装一系列的软件了</p><p><img src="image-20220114232003938.png" alt="image-20220114232003938"></p><p>只要你敢想，在手机上运行Linux的程序不是问题，就是需要注意点linux的软件架构，下载对应的软件</p><p><img src="image-20220114232557547.png" alt="image-20220114232557547"></p><p>最后，<code>stopvnc</code>就退出了</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Termux </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android 嵌入python 互交</title>
      <link href="2021/12/25/android-qian-ru-python-hu-jiao/"/>
      <url>2021/12/25/android-qian-ru-python-hu-jiao/</url>
      
        <content type="html"><![CDATA[<h1 id="android-嵌入python-互交"><a href="#android-嵌入python-互交" class="headerlink" title="android 嵌入python 互交"></a>android 嵌入python 互交</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>都知道，之所以python十分强大，是因为其包含许多的库，通过这些库的拓展，实现许多需要的功能，由此想到了如果这些功能能够被移植到android平台的app上，应用一定十分广泛。</p><p>Google开发的android studio就能够直接使用Python开发app，实现java与Python互交。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>既然要实现在android平台，python与Java互交，就必须想到一个工具，<code>Chaquopy</code>，<code>Chaquopy</code>的作用就是在Android Studio添加Python环境，java与Python互调，打包安装后安卓apk文件能够正常运行。</p><ul><li>前提在Windows设备上已经安装了Android Studio和Python环境</li><li>Android Studio的Gradle的版本需要在3.1.0以上</li><li>Android SDK的版本在16以上</li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>新建一个Android工程，在项目的目录下的build.gradle文件中，添加下面内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        ...</span><br><span class="line">        maven &#123; url &quot;https://chaquo.com/maven&quot; &#125;  #add code</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        ...</span><br><span class="line">        classpath &quot;com.chaquo.python:gradle:8.0.0&quot;  #add code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20211223212151622.png" alt="image-20211223212151622"></p><p>在app/build.gradle文件里面需要使用插件<code>com.chaquo.python</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">&#x27;com.chaquo.python&#x27;</span></span><br></pre></td></tr></table></figure><p>可以指定一下abi,如果需要在模拟器下运行，可以增加<code>x86</code>，但是一般指定<code>armeabi-v7a</code>即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ndk &#123;</span><br><span class="line">            <span class="comment">// 指定abi，如需在模拟器调试，增加&quot;x86&quot;，否则指定&quot;armeabi-v7a&quot;即可</span></span><br><span class="line">            abiFilters &quot;armeabi-v7a&quot;, &quot;x86&quot; #add code</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在此，还得指明python的路径，<code>C:/Users/admin/AppData/Local/Programs/Python/Python39/python.exe</code>是我python3.9的默认安装目录，这里必须替换成自己的python路径。</p><p>项目需要安装运行的python库可以通过pip安装，比如，安装<code>numpy</code>库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">python &#123;</span><br><span class="line">           <span class="comment">// 指定python路径</span></span><br><span class="line">     buildPython <span class="string">&quot;C:/Users/admin/AppData/Local/Programs/Python/Python39/python.exe&quot;</span></span><br><span class="line">           <span class="comment">// 安装python库</span></span><br><span class="line">      pip &#123;</span><br><span class="line">               install <span class="string">&quot;numpy&quot;</span></span><br><span class="line">               install <span class="string">&quot;scipy&quot;</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><img src="image-20211223213026353.png" alt="image-20211223213026353"></p><p>配置完成后，可以通过右上角的”Sync Now”检查一下，如果没有报错，就代表配置成功了。build框中会提示<code>synced successfully</code></p><p>为了在Android Studio直接编写python文件，可以安装一下编辑的插件</p><p>点击<strong>File</strong> -&gt; <strong>setting</strong> 到设置界面，点击<strong>plugin</strong>，搜索<strong>python</strong>，在搜索结果中选择并安装<strong>Python Community Edition</strong>，安装成功之后，按钮会变为<strong>Restart IDE</strong>，重启Android Studio即可；</p><p><em>在python</em>文件夹上点击右键，如果在“<strong>new</strong>”中可以看到“<strong>Python File</strong>”，则表示配置文件<strong>成功！！！</strong></p><p>重启后右击前文提及的<em>src/main</em>目录下名为“<em>python</em>”的文件夹，如果在“<strong>new</strong>”中有“<strong>Python File</strong>”，则表示配置文件成功！！！</p><p><img src="image-20211223222743731.png" alt="image-20211223222743731"></p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>首先新建一个python文件夹，在<code>app/src/main/</code>文件夹下鼠标右键，在<code>new</code>里面的<code>python package</code>新建一个Python文件夹，里面会默认生成一个<code>__init__.py</code>的python的python文件。</p><p><img src="image-20211225143534656.png" alt="image-20211225143534656"></p><h2 id="Java调用python"><a href="#Java调用python" class="headerlink" title="Java调用python"></a>Java调用python</h2><p>用于实例，就在python这个文件夹下新建一个<code>mypython.py</code>文件，可以在里面写入以下内容用于测试。</p><p><code>app/src/main/python/mypython.py</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getString</span>():</span></span><br><span class="line">    <span class="built_in">str</span>=<span class="string">&quot;hi python&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span></span><br></pre></td></tr></table></figure><p>就是用python定义了一个函数，<code>getString()</code>,用来返回字符串“hi python”</p><p><img src="image-20211225144721421.png" alt="image-20211225144721421"></p><p>下面，在<code>MainActivity</code>里面初始化一下python,可以使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化python</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPython</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (! Python.isStarted()) &#123;</span><br><span class="line">         Python.start(<span class="keyword">new</span> AndroidPlatform(<span class="keyword">this</span>));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>并把<code>initPython()</code>放在<code>onCreate()</code>方法里面调用。</p><p>为了显示Java调用python 的效果，可以使用一个<code>TextView</code>来显示调用python传过来的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TextView tv=(TextView)findViewById(R.id.my_id);</span><br></pre></td></tr></table></figure><p>下面就开始调用，把调用代码就放在<code>startpython()</code>私有方法里面吧，可以随意</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startpython</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Python py = Python.getInstance();</span><br><span class="line">        PyObject pyo= Python py = Python.getInstance();</span><br><span class="line">        tv.setText(pyo.toJava(String.class));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>第二行<code>Python py = Python.getInstance();</code>是用来创建一个python的接口</li><li>第三行<code>py.getModule(&quot;mypython&quot;).callAttr(&quot;getString&quot;);</code>的意思是调用mypython文件里面的getStrintg函数，得到一个<code>PyObject</code>的对象</li><li><code>pyo.toJava(String.class)</code>就是将<code>PyObject</code>转换为java的数据类型</li></ul><p>pyo表示调用函数之后的返回值，因为Python中的数据类型和Java中有些不一样，所以一般不能直接使用，需要进行转换，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.如果Python函数return(以上述obj1为例)为int类型，需要使用一下语句进行转换：  </span></span><br><span class="line">Integer result = obj1.toJava(Integer.class);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//2.如果Python函数return为一维int的list类型，使用以下语句进行转换：  </span></span><br><span class="line"><span class="keyword">int</span>[] result = obj1.toJava(<span class="keyword">int</span>[].class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.如果Python函数return为二维int的list类型，使用以下语句进行转换：  </span></span><br><span class="line"><span class="keyword">int</span>[][] result = obj1.toJava(<span class="keyword">int</span>[][].class);</span><br></pre></td></tr></table></figure><p>然后，java调用python的完整代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    Python py;</span><br><span class="line">    TextView tv;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        tv=(TextView)findViewById(R.id.my_id);</span><br><span class="line">        initPython();</span><br><span class="line">        startpython();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化python</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPython</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (! Python.isStarted()) &#123;</span><br><span class="line">            Python.start(<span class="keyword">new</span> AndroidPlatform(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startpython</span><span class="params">()</span></span>&#123;</span><br><span class="line">        py = Python.getInstance();</span><br><span class="line">        PyObject pyo= py.getModule(<span class="string">&quot;mypython&quot;</span>).callAttr(<span class="string">&quot;getString&quot;</span>);</span><br><span class="line">        tv.setText(pyo.toJava(String.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20211225151155554.png" alt="image-20211225151155554"></p><p>通过编译在真机中的显示如下</p><p><img src="image-20211225151732442.png" alt="image-20211225151732442"></p><p>显然，java调用python成功，并返回了python中字符串的值</p><h2 id="python调用java"><a href="#python调用java" class="headerlink" title="python调用java"></a>python调用java</h2><p>首先，为了演示例子，新建一个java的储存类<code>pythonclass</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">pythonclass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String val;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">pythonclass</span><span class="params">(String val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val=val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name:&quot;</span>+name+<span class="string">&quot;-age:&quot;</span>+age+<span class="string">&quot;-val:&quot;</span>+val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20211225152449996.png" alt="image-20211225152449996"></p><p>然后新建一个python的文件来调用java代码</p><p><code>app/src/main/python/pythonUsejava.py</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> java <span class="keyword">import</span> jclass</span><br><span class="line"><span class="comment"># python调用Java类</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_java_test</span>():</span></span><br><span class="line">    pythonclass = jclass(<span class="string">&quot;com.qqq.pytest.pythonclass&quot;</span>)<span class="comment">#用自己的包名</span></span><br><span class="line">    javaobj = pythonclass(<span class="string">&quot;good success&quot;</span>)</span><br><span class="line">    javaobj.setName(<span class="string">&quot;python-java&quot;</span>)</span><br><span class="line">    javaobj.setAge(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> javaobj</span><br></pre></td></tr></table></figure><p>在python代码里面，可以引入一些python库的文件，必须在<code>app/build.gradle</code>里面安装，安装后编写python代码可能报错未找到这些pyyhon库,可以无视，编译后安装的app可以运行的</p><p>为了调用这个python文件，还是得先使用java调用python，然后python调用java,实现代码之间的互交。</p><p>在<code>Python py = Python.getInstance();</code>执行之后，使用java调用一下pythonUsejava.py里面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pythontojava</span><span class="params">()</span></span>&#123;</span><br><span class="line">        PyObject pyo=py.getModule(<span class="string">&quot;pythonUsejava&quot;</span>).callAttr(<span class="string">&quot;get_java_test&quot;</span>);</span><br><span class="line">        pythonclass pc= pyo.toJava(pythonclass.class);</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>,pc.getAll(),Toast.LENGTH_LONG).show();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>之后使用Toast显示调用后返回修改的内容</p><p>为了方便，就在TextView添加点击事件，调用“pythontojava()”函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tv.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                pythontojava();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>最后，全文完整的MainActivity的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    Python py;</span><br><span class="line">    TextView tv;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        tv=(TextView)findViewById(R.id.my_id);</span><br><span class="line">        initPython();</span><br><span class="line">        startpython();</span><br><span class="line">        tv.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                pythontojava();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化python</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPython</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (! Python.isStarted()) &#123;</span><br><span class="line">            Python.start(<span class="keyword">new</span> AndroidPlatform(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startpython</span><span class="params">()</span></span>&#123;</span><br><span class="line">        py = Python.getInstance();</span><br><span class="line">        PyObject pyo= py.getModule(<span class="string">&quot;mypython&quot;</span>).callAttr(<span class="string">&quot;getString&quot;</span>);</span><br><span class="line">        tv.setText(pyo.toJava(String.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pythontojava</span><span class="params">()</span></span>&#123;</span><br><span class="line">        PyObject pyo=py.getModule(<span class="string">&quot;pythonUsejava&quot;</span>).callAttr(<span class="string">&quot;get_java_test&quot;</span>);</span><br><span class="line">        pythonclass pc= pyo.toJava(pythonclass.class);</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>,pc.getAll(),Toast.LENGTH_LONG).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20211225154516548.png" alt="image-20211225154516548"></p><p>运行并点击TextView 的效果如下</p><p><img src="image-20211225154822233.png" alt="image-20211225154822233"></p><p>运行成功</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>Chaquopy（Python SDK for Android）官方链接：<br><a href="https://chaquo.com/chaquopy/">https://chaquo.com/chaquopy/</a></p><p>Android-Python混合开发 1 （java和python互相调用）：</p><p><a href="https://www.jianshu.com/p/a875b0f37a88">https://www.jianshu.com/p/a875b0f37a88</a></p><p>Android studio中编写Python代码-1：</p><p><a href="https://www.jianshu.com/p/73bd89712ddb">https://www.jianshu.com/p/73bd89712ddb</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对 栈 的理解</title>
      <link href="2021/12/18/dui-zhan-de-li-jie/"/>
      <url>2021/12/18/dui-zhan-de-li-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="对-栈-的理解"><a href="#对-栈-的理解" class="headerlink" title="对 栈 的理解"></a>对 栈 的理解</h1><h2 id="一，初始"><a href="#一，初始" class="headerlink" title="一，初始"></a>一，初始</h2><p>栈是一种具有特殊访问方式的储存空间。它的特殊性就在于，最后进入这个空间的数据，最先出去。</p><ul><li>可以用一个盒子和3本书描述<img src="810k6-c3lav.gif" alt="img"></li></ul><p>可以想象一下，如果这三本书是一行行代码，那么，它的解释入栈和出栈原理就是和图中所示的大概一样。</p><h2 id="二、栈的操作"><a href="#二、栈的操作" class="headerlink" title="二、栈的操作"></a>二、栈的操作</h2><ul><li>入栈：将一个新的元素放到栈顶</li><li>出栈：从栈顶取出一个元素</li></ul><blockquote><p>栈顶的元素总是最后入栈，需要出栈时，又总是最先被从栈中取出</p><p>这种操作规则：LIFO（Last in First out,后进先出）</p></blockquote><p>一般来说，在汇编中，入栈和出栈的指令是最基本的，push(入栈)，pop(出栈)</p><p>如：</p><p><code>push ax</code>将寄存器ax中的数据送入栈中</p><p><code>pop ax</code>从栈顶取出数据放到ax寄存器中</p><blockquote><p><code>8086CPU</code>的入栈和出栈方式都是以字(16位)为单位进行的</p></blockquote><h2 id="三、举例理解"><a href="#三、举例理解" class="headerlink" title="三、举例理解"></a>三、举例理解</h2><p>如果将<code>10000H~1000FH</code>这段内存当做栈来使用，理解以下指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">push ax</span><br><span class="line">mov bx,2266H</span><br><span class="line">push bx</span><br><span class="line">mov cx,1122H</span><br><span class="line">push cx</span><br><span class="line">pop ax</span><br><span class="line">pop bx</span><br><span class="line">pop cx</span><br></pre></td></tr></table></figure><p>分解指令理解</p><ul><li><p>初始栈的模型</p><p><img src="image-20211218142551845.png" alt="image-20211218142551845"></p></li><li><p><code>mov ax,0123H</code>和<code>push ax</code> </p><p>将<code>0123H</code>放入ax中，然后将ax中的数据push 进栈</p><p><img src="image-20211218142851085.png" alt="image-20211218142851085"></p></li><li><p>同理，<code> mov bx,2266H</code>和<code>push bx</code></p><p>将<code>2266H</code>放入bx寄存器中，再将bx中的数据push进栈</p><p><img src="image-20211218143350528.png" alt="image-20211218143350528"></p></li><li><p>同理，<code>mov cx,1122H</code>和<code>push cx</code></p><p><img src="image-20211218143631913.png" alt="image-20211218143631913"></p></li><li><p><code>pop ax</code></p><p><code>pop</code>指令是将栈顶的元素取出，放入ax中,由于这时栈顶的元素数据是<code>1122H</code>，所以将其取出</p><p><img src="image-20211218144052750.png" alt="image-20211218144052750"></p></li><li><p><code>pop bx</code></p><p>同理，这时pop取出栈顶的元素<code>2266H</code>,并放入bx中</p><p><img src="image-20211218144721558.png" alt="image-20211218144721558"></p></li><li><p><code>pop cx</code></p><p>这时取出<code>0123H</code>，将其放入cx中</p><p><img src="image-20211218145729752.png" alt="image-20211218145729752"></p></li></ul><p>由此，一个程序执行完毕，栈就恢复了原始状态</p><blockquote><p>注意：字形数据用两个单元存放，高地址放高8位，低地址放低8位</p></blockquote><h2 id="四、CPU如何知道指令位置"><a href="#四、CPU如何知道指令位置" class="headerlink" title="四、CPU如何知道指令位置"></a>四、CPU如何知道指令位置</h2><p>通过了一个例子的执行，可能有个问题，CPU是如何知道要执行指令的位置</p><p>答案是，寄存器<code>CS</code>和<code>IP</code>中存放着当前指令的段地址和偏移地址，并且，在任意时刻，<code>SS:SP</code>都指向栈顶的元素。</p><ul><li><p>段寄存器SS: 存放栈顶的段地址</p></li><li><p>寄存器SP：存放栈顶的偏移地址</p><h3 id="push深刻理解"><a href="#push深刻理解" class="headerlink" title="push深刻理解"></a>push深刻理解</h3></li></ul><p><code>push ax</code>事实上执行了两步操作，</p><ol><li><p><code>SP=SP-2</code></p></li><li><p>将ax中的内容送入<code>SS:SP</code>指向的内存单元处，<code>SS:SP</code>指向新的栈顶</p></li></ol><p><img src="image-20211218151824132.png" alt="image-20211218151824132"></p><h3 id="pop深刻理解"><a href="#pop深刻理解" class="headerlink" title="pop深刻理解"></a>pop深刻理解</h3><p>pop与push是逆运算，<code>pop ax</code>同样也需要执行两步操作</p><ol><li>将<code>SS:SP</code>指向的单元中的数据取出，放到ax中</li><li><code>SP=SP+2</code>，这时<code>SS:SP</code>指向了新的单元</li></ol><p><img src="image-20211218153457919.png" alt="image-20211218153457919"></p><p>由上面两步可以看出，所谓 ’取出‘ 数据，其实，并只取出了数据，并没有删除内存中的数据，而是将<code>SS:IP</code>的指向改变了，原来存入的数据还在，若想要删除，只能用新的数据覆盖</p><h2 id="五、栈的大小"><a href="#五、栈的大小" class="headerlink" title="五、栈的大小"></a>五、栈的大小</h2><p>因为<code>SS:SP</code>只记录了栈顶的地址，依靠SS和SP可以保证入栈和出栈时找到栈顶，如何保证在入栈和出栈时，栈顶不会超出栈空间？</p><p>即是</p><ul><li>当栈满的时候再使用push指令入栈</li><li>当栈空的时候再使用pop指令出栈</li></ul><p>这就会导致栈顶超界问题，非常危险</p><ol><li><p>栈顶超界</p><p><img src="g6bmg-yh3ty.gif" alt="img"></p></li><li><p>栈底超界</p><p><img src="srnvk-bun1d.gif" alt="img"></p></li></ol><p>以上演示图片说明，栈顶超界是危险的</p><p>因为我们既然将一段空间安排为栈，那么在栈空间之外的空间里很可能存放了具有其它用途的数据、代码，可能是我们自己程序中的，也可能是别的程序中的，毕竟在计算机中并不是只有我们自己的程序在运行。</p><p>这就是所谓的<code>栈溢出</code>,从黑客角度，就是<code>溢出攻击</code></p><h2 id="六、设置栈"><a href="#六、设置栈" class="headerlink" title="六、设置栈"></a>六、设置栈</h2><p>如果将<code>10000H~1000FH</code>这段空间当做栈，初始状态是空的，如何将<code>AX</code>,<code>BX</code>,<code>DS</code>中的数据入栈？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ss,ax ;设置栈的段地址，SS&#x3D;1000H,不能直接向SS送入数据，用AX中转</span><br><span class="line">mov sp,0010H ;设置栈顶的偏移地址，因为栈为空，所以SP&#x3D;0010H</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push ds</span><br></pre></td></tr></table></figure><p>  栈的意义就在于暂时储存以后需要恢复的寄存器内容</p><h2 id="七、参考链接"><a href="#七、参考链接" class="headerlink" title="七、参考链接"></a>七、参考链接</h2><p>小甲鱼汇编入门：</p><p><a href="https://www.bilibili.com/video/BV1zW411n79C">https://www.bilibili.com/video/BV1zW411n79C</a></p><p>阮一峰-汇编入门教程：</p><p><a href="https://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html">https://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 原理 </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Base64 的算法原理</title>
      <link href="2021/12/13/base64-de-suan-fa-yuan-li/"/>
      <url>2021/12/13/base64-de-suan-fa-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Base64-的算法原理"><a href="#Base64-的算法原理" class="headerlink" title="Base64 的算法原理"></a>Base64 的算法原理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Base64算法是我们日常生活中必不可少的加密编码方式之一，它常用64个可打印字符表示任意字符，通常用来储存、传输一些二进制数据；在一些加密方式，可以通过了解原理后进行更深入的加密运算操作。</p><h2 id="标准表"><a href="#标准表" class="headerlink" title="标准表"></a>标准表</h2><p>由于它是使用64个可打印字符表示的数据，则一定有一种特殊的对应关系。由于2的6次方等于64，所以可以用每6个位元为一个单元，对应某个可打印字符。我们知道三个字节有24个位元，就可以刚好对应于4个Base64单元，即3个字节需要用4个Base64的可打印字符来表示。在Base64中的可打印字符包括字母A-Z、a-z、数字0-9 ，这样共有62个字符，此外两个可打印符号在不同的系统中一般有所不同。但是，我们经常所说的Base64另外2个字符是：“+/”。这64个字符，所对应表如下</p><table border="1" rules="all" cellspacing="0" align="center"><tbody><tr><th scope="col">编号</th><th scope="col">字符</th><th rowspan="18">&nbsp;</th><th scope="col">编号</th><th scope="col">字符</th><th rowspan="18">&nbsp;</th><th scope="col">编号</th><th scope="col">字符</th><th rowspan="18">&nbsp;</th><th scope="col">编号</th><th scope="col">字符</th></tr><tr><td>0</td><td>A</td><td>16</td><td>Q</td><td>32</td><td>g</td><td>48</td><td>w</td></tr><tr><td>1</td><td>B</td><td>17</td><td>R</td><td>33</td><td>h</td><td>49</td><td>x</td></tr><tr><td>2</td><td>C</td><td>18</td><td>S</td><td>34</td><td>i</td><td>50</td><td>y</td></tr><tr><td>3</td><td>D</td><td>19</td><td>T</td><td>35</td><td>j</td><td>51</td><td>z</td></tr><tr><td>4</td><td>E</td><td>20</td><td>U</td><td>36</td><td>k</td><td>52</td><td>0</td></tr><tr><td>5</td><td>F</td><td>21</td><td>V</td><td>37</td><td>l</td><td>53</td><td>1</td></tr><tr><td>6</td><td>G</td><td>22</td><td>W</td><td>38</td><td>m</td><td>54</td><td>2</td></tr><tr><td>7</td><td>H</td><td>23</td><td>X</td><td>39</td><td>n</td><td>55</td><td>3</td></tr><tr><td>8</td><td>I</td><td>24</td><td>Y</td><td>40</td><td>o</td><td>56</td><td>4</td></tr><tr><td>9</td><td>J</td><td>25</td><td>Z</td><td>41</td><td>p</td><td>57</td><td>5</td></tr><tr><td>10</td><td>K</td><td>26</td><td>a</td><td>42</td><td>q</td><td>58</td><td>6</td></tr><tr><td>11</td><td>L</td><td>27</td><td>b</td><td>43</td><td>r</td><td>59</td><td>7</td></tr><tr><td>12</td><td>M</td><td>28</td><td>c</td><td>44</td><td>s</td><td>60</td><td>8</td></tr><tr><td>13</td><td>N</td><td>29</td><td>d</td><td>45</td><td>t</td><td>61</td><td>9</td></tr><tr><td>14</td><td>O</td><td>30</td><td>e</td><td>46</td><td>u</td><td>62</td><td>+</td></tr><tr><td>15</td><td>P</td><td>31</td><td>f</td><td>47</td><td>v</td><td>63</td><td>/</td></tr></tbody></table>有的加密就是通过魔改base64标准表，进而达到加密效果<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p> 对于任意字符串，将三个byte的数据，先后放入一个24bit的缓冲区中，先来的byte占高位。数据不足3byte的话，于缓冲区中剩下的bit用0补足。然后，每次取出6个bit，按照其值选择<code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</code>中的字符作为编码后的输出。不断进行，直到全部输入数据转换完成。</p><p>  如果最后剩下两个输入数据，在编码结果后加1个“=”；如果最后剩下一个输入数据，编码结果后加2个“=”；如果没有剩下任何数据，就什么都不要加，这样才可以保证资料还原的正确性。</p><p>  编码后的数据比原始数据略长，为原来的4/3。无论什么样的字符都会全部被编码。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><table border="1" rules="all" cellspacing="0" align="center"><tbody><tr><th scope="row">文本</th><td colspan="8" align="center"><strong>M</strong></td><td colspan="8" align="center"><strong>a</strong></td><td colspan="8" align="center"><strong>n</strong></td></tr><tr><th scope="row">ASCII编码</th><td colspan="8" align="center">77</td><td colspan="8" align="center">97</td><td colspan="8" align="center">110</td></tr><tr><th scope="row">二进制位</th><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><th scope="row">索引</th><td colspan="6" align="center">19</td><td colspan="6" align="center">22</td><td colspan="6" align="center">5</td><td colspan="6" align="center">46</td></tr><tr><th scope="row">Base64编码</th><td colspan="6" align="center"><strong>T</strong></td><td colspan="6" align="center"><strong>W</strong></td><td colspan="6" align="center"><strong>F</strong></td><td colspan="6" align="center"><strong>u</strong></td></tr></tbody></table><table  border="1" rules="all" cellspacing="0" align="center"><tbody><tr><th scope="row">文本（1 Byte）</th><td colspan="8" align="center"><strong>A</strong></td><td colspan="8" align="center">&nbsp;</td><td colspan="8" align="center">&nbsp;</td></tr><tr><th scope="row">二进制位</th><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><th scope="row">二进制位（补0）</th><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td><strong>0</strong></td><td><strong>0</strong></td><td><strong>0</strong></td><td><strong>0</strong></td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><th scope="row">Base64编码</th><td colspan="6" align="center"><strong>Q</strong></td><td colspan="6" align="center"><strong>Q</strong></td><td colspan="6" align="center"><strong>=</strong></td><td colspan="6" align="center"><strong>=</strong></td></tr><tr><th scope="row">文本（2 Byte）</th><td colspan="8" align="center"><strong>B</strong></td><td colspan="8" align="center"><strong>C</strong></td><td colspan="8" align="center">&nbsp;</td></tr><tr><th scope="row">二进制位</th><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>&nbsp;</td><td>&nbsp;</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td></tr><tr><th scope="row">二进制位（补0）</th><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td><strong>0</strong></td><td><strong>0</strong></td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td></tr><tr><th scope="row">Base64编码</th><td colspan="6" align="center"><strong>Q</strong></td><td colspan="6" align="center"><strong>k</strong></td><td colspan="6" align="center"><strong>M</strong></td><td colspan="6" align="center">&nbsp;<strong>=</strong></td></tr></tbody></table><h2 id="链接引用"><a href="#链接引用" class="headerlink" title="链接引用"></a>链接引用</h2><p>Base64 算法原理，以及编码、解码【加密、解密】 介绍：</p><p><a href="http://blog.chacuo.net/719.html">http://blog.chacuo.net/719.html</a></p><p>用js实现的Base64加解密工具：</p><p><a href="https://kuangtant.gitee.io/tools/base64/">https://kuangtant.gitee.io/tools/base64/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android studio生成so文件</title>
      <link href="2021/12/12/android-studio-sheng-cheng-so-wen-jian/"/>
      <url>2021/12/12/android-studio-sheng-cheng-so-wen-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-studio生成so文件"><a href="#Android-studio生成so文件" class="headerlink" title="Android studio生成so文件"></a>Android studio生成so文件</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>现在，大部分安卓app的开发几乎都是使用java完成，但是，Java在速度和一些功能上可能不如c/c++程序，并且一些好的开源项目是使用c/c++开发完成的，为了使用这一功能，android拓展了jni,提供这一服务。</p><h2 id="二、-NDK"><a href="#二、-NDK" class="headerlink" title="二、 NDK"></a>二、 NDK</h2><h3 id="2-1-理解ndk"><a href="#2-1-理解ndk" class="headerlink" title="2.1 理解ndk"></a>2.1 理解ndk</h3><p>在Android OS上开发应用程序，Google提供了两种开发包：SDK和NDK,Android 平台从一开就已经支持了C/C++了。我们知道Android的SDK主要是基于Java的，所以导致了在用Android SDK进行开发的工程师们都必须使用Java语言。不过，Google从一开始就说明Android也支持JNI编程方式，也就是第三方应用完成可以通过JNI调用自己的C动态度。于是NDK就应运而生了。</p><h3 id="2-2-为何ndk"><a href="#2-2-为何ndk" class="headerlink" title="2.2  为何ndk"></a>2.2  为何ndk</h3><ul><li><p>1、在平台之间移植其应用</p></li><li><p>2、重复使用现在库，或者提供其自己的库重复使用</p></li><li><p>3、在某些情况下提性能，特别是像游戏这种计算密集型应用</p></li><li><p>4、使用第三方库，现在许多第三方库都是由C/C++库编写的，比如Ffmpeg这样库。</p></li><li><p>5、不依赖于Dalvik Java虚拟机的设计</p></li><li><p>6、代码的保护。由于APK的Java层代码很容易被反编译，而C/C++库反编译难度大</p></li></ul><h3 id="2-3-从NDK到so"><a href="#2-3-从NDK到so" class="headerlink" title="2.3 从NDK到so"></a>2.3 从NDK到so</h3><p><img src="1.webp" alt="img"></p><p>从上图这个Android系统框架来看，我们上层通过JNI来调用NDK层的，使用这个工具可以很方便的编写和调试JNI的代码。因为C语言的不跨平台，在Mac系统的下使用NDK编译在Linux下能执行的函数库——so文件。其本质就是一堆C、C++的头文件和实现文件打包成一个库。目前Android系统支持以下七种不用的CPU架构，每一种对应着各自的应用程序二进制接口ABI：(Application Binary Interface)定义了二进制文件(尤其是.so文件)如何运行在相应的系统平台上，从使用的指令集，内存对齐到可用的系统函数库。对应关系如下：</p><blockquote><ul><li>ARMv5——armeabi</li><li>ARMv7 ——armeabi-v7a</li><li>ARMv8——arm64- v8a</li><li>x86——x86</li><li>MIPS ——mips</li><li>MIPS64——mips64</li><li>x86_64——x86_64</li></ul></blockquote><h2 id="三、JNI"><a href="#三、JNI" class="headerlink" title="三、JNI"></a>三、JNI</h2><h3 id="3-1-解释jni"><a href="#3-1-解释jni" class="headerlink" title="3.1 解释jni"></a>3.1 解释jni</h3><p>JNI，全称为Java Native Interface，即Java本地接口，JNI是Java调用Native 语言的一种特性。通过JNI可以使得Java与C/C++机型交互。即可以在Java代码中调用C/C++等语言的代码或者在C/C++代码中调用Java代码。由于JNI是JVM规范的一部分，因此可以将我们写的JNI的程序在任何实现了JNI规范的Java虚拟机中运行。同时，这个特性使我们可以复用以前用C/C++写的大量代码JNI是一种在Java虚拟机机制下的执行代码的标准机制。代码被编写成汇编程序或者C/C++程序，并组装为动态库。也就允许非静态绑定用法。这提供了一个在Java平台上调用C/C++的一种途径，反之亦然。</p><p>PS：<br> 开发JNI程序会受到系统环境限制，因为用C/C++ 语言写出来的代码或模块，编译过程当中要依赖当前操作系统环境所提供的一些库函数，并和本地库链接在一起。而且编译后生成的二进制代码只能在本地操作系统环境下运行，因为不同的操作系统环境，有自己的本地库和CPU指令集，而且各个平台对标准C/C++的规范和标准库函数实现方式也有所区别。这就造成了各个平台使用JNI接口的Java程序，不再像以前那样自由的跨平台。如果要实现跨平台， 就必须将本地代码在不同的操作系统平台下编译出相应的动态库。</p><h3 id="3-2-为何jni"><a href="#3-2-为何jni" class="headerlink" title="3.2 为何jni"></a>3.2 为何jni</h3><p>可以使用Java代码和C/C++进行交互，与其它类似接口Microsoft的原始本地接口等相比，JNI的主要竞争优势在于：它在设计之初就确保了二进制的兼容性，JNI编写的应用程序兼容性以及其再某些具体平台上的Java虚拟机兼容性(当谈及JNI时，这里并不特比针对Davik虚拟机，JNI适用于所有JVM虚拟机)。这就是为什么C/C++编译后的代码无论在任何平台上都能执行。不过，一些早期版本并不支持二进制兼容。二进制兼容性是一种程序兼容性类型，允许一个程序在不改变其可执行文件的条件下在不同的编译环境中工作。</p><h3 id="3-3-工作原理"><a href="#3-3-工作原理" class="headerlink" title="3.3 工作原理"></a>3.3 工作原理</h3><p><img src="2.webp" alt="img"></p><p><img src="3.webp" alt="img"></p><p>JNI是作为一个桥梁的作用，链接java和c/c++</p><h3 id="3-4-命名"><a href="#3-4-命名" class="headerlink" title="3.4 命名"></a>3.4 命名</h3><p>例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIExport jstring JNICALL <span class="title">Java_com_example_hellojni_MainActivity_stringFromJNI</span><span class="params">( JNIEnv* env,jobject thiz )</span> </span></span><br></pre></td></tr></table></figure><p><strong><code>jstring</code></strong> 是<strong>返回值类型</strong><br> <strong><code>Java_com_example_hellojni</code></strong> 是<strong>包名</strong><br> <strong><code>MainActivity</code></strong> 是<strong>类名</strong><br> <strong><code>stringFromJNI</code></strong> 是<strong>方法名</strong></p><p>其中**<code>JNIExport</code><strong>和</strong><code>JNICALL</code>**是不固定保留的关键字不要修改</p><h3 id="3-5-JNI开发流程"><a href="#3-5-JNI开发流程" class="headerlink" title="3.5 JNI开发流程"></a>3.5 JNI开发流程</h3><blockquote><ul><li>第1步：在Java中先声明一个native方法</li><li>第2步：编译Java源文件javac得到.class文件</li><li>第3步：通过javah -jni命令导出JNI的.h头文件</li><li>第4步：使用Java需要交互的本地代码，实现在Java中声明的Native方法（如果Java需要与C++交互，那么就用C++实现Java的Native方法。）</li><li>第5步：将本地代码编译成动态库(Windows系统下是.dll文件，如果是Linux系统下是.so文件，如果是Mac系统下是.jnilib)</li><li>第6步：通过Java命令执行Java程序，最终实现Java调用本地代码。</li></ul></blockquote><p>PS：javah 是JDK自带的一个命令，-jni参数表示将class 中用到native 声明的函数生成JNI 规则的函数</p><p><img src="webp.webp" alt="img"></p><h2 id="四、实现一个JNI例子"><a href="#四、实现一个JNI例子" class="headerlink" title="四、实现一个JNI例子"></a>四、实现一个JNI例子</h2><h3 id="4-1-创建app"><a href="#4-1-创建app" class="headerlink" title="4.1 创建app"></a>4.1 创建app</h3><p>打开android studio,新建一个project, Create Android Project</p><p><img src="image-20211212162000770.png" alt="image-20211212162000770"></p><p>这里可以勾选Include C++ support, Android studio会给出一个使用JNI的例子。</p><h3 id="4-2-创建-测试类"><a href="#4-2-创建-测试类" class="headerlink" title="4.2 创建 测试类"></a>4.2 创建 测试类</h3><p>新建一个testso的java类，在里面声明一个native方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qqq.sotest.sotest;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by admin on 2021/12/12.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testso</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;so-lib&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">getJniTestString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="4.png" alt="image-20211212162936951"></p><p>注意，loadLibrary的是在CMakeLists.txt设置的library的名字，而不是c文件名</p><h3 id="4-3-创建c文件"><a href="#4-3-创建c文件" class="headerlink" title="4.3 创建c文件"></a>4.3 创建c文件</h3><p>在app/src/main/cpp/目录下新建一个so-test.c的文件，实现c语言方法，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_qqq_sotest_sotest_testso_getJniTestString</span><br><span class="line">        (JNIEnv * env, jclass object)&#123;</span><br><span class="line">    <span class="keyword">return</span> (*env)-&gt;NewStringUTF(env,<span class="string">&quot;测试 jni&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20211212164349767.png" alt="image-20211212164349767"></p><p>创建c文件里面的<code>JNICALL Java_xxxx_xxxx_xxxx</code>必须遵循命名规则。</p><h3 id="4-4-添加到CMakeLists-txt"><a href="#4-4-添加到CMakeLists-txt" class="headerlink" title="4.4 添加到CMakeLists.txt"></a>4.4 添加到CMakeLists.txt</h3><p>需要把so-test.c文件告诉Android Studio，通过CMake修改</p><p>在app/src/main/CMakeLists.txt添加如下内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add_library( # Sets the name of the library.</span><br><span class="line">             so-lib</span><br><span class="line"></span><br><span class="line">             # Sets the library as a shared library.</span><br><span class="line">             SHARED</span><br><span class="line"></span><br><span class="line">             # Provides a relative path to your source file(s).</span><br><span class="line">             src/main/cpp/so-test.c )</span><br></pre></td></tr></table></figure><p><code>so-lib</code>设置library的名字,在java代码里引用</p><p><code>SHARED</code>将其设为共享的library</p><p><code>src/main/cpp/so-test.c</code> c文件的路径</p><p><img src="image-20211212165436159.png" alt="image-20211212165436159"></p><h3 id="4-5-构建"><a href="#4-5-构建" class="headerlink" title="4.5 构建"></a>4.5 构建</h3><p>点击<code>Build</code>-&gt;<code>Make Project</code>构建，或者<code>ctrl</code>+<code>F9</code>构建， 再运行</p><p>这样，c/cpp文件就被打包成so文件了。</p><p><img src="image-20211212171338595.png" alt="image-20211212171338595"></p><p>打包完成后so文件会放在apk的lib/文件夹里</p><p><img src="enbd8-nseor.gif" alt="enbd8-nseor"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><p>Android JNI(一)——NDK与JNI基础：</p><p><a href="https://www.jianshu.com/p/87ce6f565d37">https://www.jianshu.com/p/87ce6f565d37</a></p></li><li><p>Android Studio生成so文件的几种方式：</p><p><a href="https://www.jianshu.com/p/faa3eebbd401">https://www.jianshu.com/p/faa3eebbd401</a></p></li><li><p>Android studio 编译NDK Android studio 生成.so文件：</p><p><a href="https://www.jianshu.com/p/4c7d9a10933b">https://www.jianshu.com/p/4c7d9a10933b</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASCII 转换工具</title>
      <link href="2021/12/03/ascii-zhuan-huan-gong-ju/"/>
      <url>2021/12/03/ascii-zhuan-huan-gong-ju/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在日常学习过程中，难免有些进制转换的问题，比如ASCII转2,10，16进制等，就可以使用如下工具</p><iframe style="width:100%; height:260;border:none;text-align:center" allowtransparency="yes" frameborder="0" width="100%" height="1000" src="https://kuangtant.gitee.io/tools/asscii/"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python自动android操作</title>
      <link href="2021/11/18/python-zi-dong-android-cao-zuo/"/>
      <url>2021/11/18/python-zi-dong-android-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h1 id="python-自动安卓操作"><a href="#python-自动安卓操作" class="headerlink" title="python 自动安卓操作"></a>python 自动安卓操作</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近，由于某些原因，不得不在安卓上自动操作一些东西，就开始了本教程。目的就是为了用python写脚本，进而控制android手机操作一些内容，其实挺简单的，仅需要一点python基础就可以了</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>由于需要操控android,一些准备是必不可少的</p><h3 id="ADB"><a href="#ADB" class="headerlink" title="ADB"></a>ADB</h3><p><code>adb</code>是安卓调试桥，必须在PC上安装</p><p><code>adb</code>下载地址:<a href="https://developer.android.google.cn/studio/releases/platform-tools">https://developer.android.google.cn/studio/releases/platform-tools</a> </p><p><img src="image-20211118180508372.png" alt="image-20211118180508372"></p><p>选择你的操作端对应的<code>SDK</code>，然后解压复制全部文件到你希望的目录，并手动把<code>adb.exe</code> 所在目录添加到环境变量。</p><p>或者在<code>cmd</code>窗口中执行(如果目录是D:\xxxx\adb.exe)</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="built_in">PATH</span>=<span class="variable">%PATH%</span>;D:\xxxx</span><br></pre></td></tr></table></figure><p>然后可以链接手机，通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure><p>来验证安装结果。</p><p><img src="webp.webp" alt="img"></p><h3 id="uiautomator2"><a href="#uiautomator2" class="headerlink" title="uiautomator2"></a>uiautomator2</h3><p>安装这个包就比较简单，直接使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --pre -U uiautomator2</span><br></pre></td></tr></table></figure><p>等待安装完成就是，其次需要注意的是，建议将pip的下载源换到国内镜像，这样下载才比较流畅</p><h3 id="android-手机环境"><a href="#android-手机环境" class="headerlink" title="android 手机环境"></a>android 手机环境</h3><p>手机链接PC后，手机上打开开发者模式，如果没有，就在系统设置中，连点4次版本号，打开开发者模式</p><p>然后开启允许USB调试，</p><p>输入adb命令<code>adb devices</code>发现设备后，表示设备链接成功。</p><p>后面在PC输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m uiautomator2 init</span><br></pre></td></tr></table></figure><p>手机上就会安装好<code>atx-agent</code></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>因为是用python写脚本，就必须导入<code>uiautomator2</code>,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> uiautomator2 <span class="keyword">as</span> u2  <span class="comment">#依赖包</span></span><br></pre></td></tr></table></figure><p>连接方式有两种</p><ul><li><p>wifi</p><p>先获取到手机的IP，并且确保电脑可以ping通电脑</p><p>IP可以在ATX这个软件上查看，也可以在wifi设置里查看</p><p>如果手机的IP是12.222.42.001，就应该这样连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> uiautomator2 <span class="keyword">as</span> u2  </span><br><span class="line">d = u2.connect(<span class="string">&#x27;12.222.42.001&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>USB</p><p>使用usb连接就比较方便，可以通过<code>adb device</code>获取到，比如连接号是abcdefg,就该</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> uiautomator2 <span class="keyword">as</span> u2</span><br><span class="line">d = u2.connect_usb(<span class="string">&#x27;abcdefg&#x27;</span>)</span><br></pre></td></tr></table></figure><p>当然了，如果pc只连接了一台手机，就可以通过</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> uiautomator2 <span class="keyword">as</span> u2</span><br><span class="line">d = u2.connect()</span><br></pre></td></tr></table></figure><p>直接连接了。</p></li></ul><h3 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h3><ul><li><p>点击click</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d(text=<span class="string">&quot;点我&quot;</span>).click()</span><br></pre></td></tr></table></figure></li><li><p>长按long click</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d(text=<span class="string">&#x27;长按我&#x27;</span>).long_click()</span><br></pre></td></tr></table></figure></li><li><p>输入文字set text</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d(text=<span class="string">&#x27;input&#x27;</span>).set_text(<span class="string">&#x27;okk&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>检查并维持设备端守护进程处于运行状态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d.healthcheck()</span><br></pre></td></tr></table></figure></li><li><p>打开调试开关</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d.debug = <span class="literal">True</span></span><br><span class="line">d.info</span><br></pre></td></tr></table></figure></li><li><p>安装应用，只能从URL安装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d.app_install(<span class="string">&#x27;http://some-domain.com/some.txt&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>启动应用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d.app_start(<span class="string">&#x27;com.eg.android.AlipayGphone&#x27;</span>) <span class="comment">#引号内为包名称，这里为支付宝</span></span><br></pre></td></tr></table></figure></li><li><p>停止应用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#相当于&#x27;am force-stop&#x27;强制停止应用</span></span><br><span class="line">d.app_stop(<span class="string">&#x27;com.eg.android.AlipayGphone&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">#相当于&#x27;pm clear&#x27; 清空App数据</span></span><br><span class="line">d.app_clear(<span class="string">&#x27;com.eg.android.AlipayGphone&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>停止所有正在运行的应用程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止所有</span></span><br><span class="line">d.app_stop_all()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止所有应用程序，除了com.examples.demo</span></span><br><span class="line">d.app_stop_all(excludes=[<span class="string">&#x27;com.examples.demo&#x27;</span>])</span><br></pre></td></tr></table></figure></li><li><p>跳过弹窗，禁止弹窗</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d.disable_popups() <span class="comment"># 自动跳过弹出窗口 </span></span><br><span class="line">d.disable_popups(<span class="literal">False</span>) <span class="comment"># 禁用自动跳过弹出窗</span></span><br></pre></td></tr></table></figure></li><li><p>获取设备信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取基本信息</span></span><br><span class="line">d.info</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取窗口大小</span></span><br><span class="line">print(d.window_size())</span><br><span class="line"><span class="comment"># 设备垂直输出示例: (1080, 1920)</span></span><br><span class="line"><span class="comment"># 设备水平输出示例: (1920, 1080)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前应用程序信息。对于某些android设备，输出可以为空</span></span><br><span class="line">print(d.current_app())</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取设备序列号</span></span><br><span class="line">print(d.serial)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取WIFI IP</span></span><br><span class="line">print(d.wlan_ip)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取详细的设备信息</span></span><br><span class="line">print(d.device_info)</span><br></pre></td></tr></table></figure></li><li><p>获取应用信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">d.app_info(<span class="string">&quot;com.eg.android.AlipayGphone&quot;</span>)</span><br><span class="line"><span class="comment"># 会输出</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string"> &quot;packageName&quot;: &quot;com.eg.android.AlipayGphone&quot;, </span></span><br><span class="line"><span class="string"> &quot;mainActivity&quot;: &quot;com.eg.android.AlipayGphone.AlipayLogin&quot;, </span></span><br><span class="line"><span class="string"> &quot;label&quot;: &quot;支付寶&quot;, </span></span><br><span class="line"><span class="string"> &quot;versionName&quot;: &quot;10.2.13.9020&quot;, </span></span><br><span class="line"><span class="string"> &quot;versionCode&quot;: 360, </span></span><br><span class="line"><span class="string"> &quot;size&quot;: 108306104</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 保存应用程序图标</span></span><br><span class="line">img = d.app_icon(<span class="string">&quot;com.eg.android.AlipayGphone&quot;</span>)</span><br><span class="line">img.save(<span class="string">&quot;icon.png&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>推送文件到设备</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># push文件夹</span></span><br><span class="line">d.push(<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&quot;/sdcard/&quot;</span>)</span><br><span class="line"><span class="comment"># push和重命名</span></span><br><span class="line">d.push(<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&quot;/sdcard/bar.txt&quot;</span>)</span><br><span class="line"><span class="comment"># push fileobj</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line"> d.push(f, <span class="string">&quot;/sdcard/&quot;</span>)</span><br><span class="line"><span class="comment"># 推动和更改文件访问模式</span></span><br><span class="line">d.push(<span class="string">&quot;foo.sh&quot;</span>, <span class="string">&quot;/data/local/tmp/&quot;</span>, mode=<span class="number">0o755</span>)</span><br></pre></td></tr></table></figure></li><li><p>从设备拉取一个文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d.pull(<span class="string">&quot;/sdcard/tmp.txt&quot;</span>, <span class="string">&quot;tmp.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果在设备上找不到文件，FileNotFoundError将引发</span></span><br><span class="line">d.pull(<span class="string">&quot;/sdcard/some-file-not-exists.txt&quot;</span>, <span class="string">&quot;tmp.txt&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>打开\关闭屏幕</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d.screen_on()＃打开屏幕 </span><br><span class="line">d.screen_off() ＃关闭屏幕</span><br></pre></td></tr></table></figure></li><li><p>获取当前屏幕状态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d.info.get(<span class="string">&#x27;screenOn&#x27;</span>) <span class="comment"># 需要 Android&gt; = 4.4</span></span><br></pre></td></tr></table></figure></li><li><p>硬键盘和软键盘操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">d.press(<span class="string">&quot;home&quot;</span>) <span class="comment"># 点击home键</span></span><br><span class="line">d.press(<span class="string">&quot;back&quot;</span>) <span class="comment"># 点击back键</span></span><br><span class="line">d.press(<span class="string">&quot;left&quot;</span>) <span class="comment"># 点击左键</span></span><br><span class="line">d.press(<span class="string">&quot;right&quot;</span>) <span class="comment"># 点击右键</span></span><br><span class="line">d.press(<span class="string">&quot;up&quot;</span>) <span class="comment"># 点击上键</span></span><br><span class="line">d.press(<span class="string">&quot;down&quot;</span>) <span class="comment"># 点击下键</span></span><br><span class="line">d.press(<span class="string">&quot;center&quot;</span>) <span class="comment"># 点击选中</span></span><br><span class="line">d.press(<span class="string">&quot;menu&quot;</span>) <span class="comment"># 点击menu按键</span></span><br><span class="line">d.press(<span class="string">&quot;search&quot;</span>) <span class="comment"># 点击搜索按键</span></span><br><span class="line">d.press(<span class="string">&quot;enter&quot;</span>) <span class="comment"># 点击enter键</span></span><br><span class="line">d.press(<span class="string">&quot;delete&quot;</span>) <span class="comment"># 点击删除按键</span></span><br><span class="line">d.press(<span class="string">&quot;recent&quot;</span>) <span class="comment"># 点击近期活动按键</span></span><br><span class="line">d.press(<span class="string">&quot;volume_up&quot;</span>) <span class="comment"># 音量+</span></span><br><span class="line">d.press(<span class="string">&quot;volume_down&quot;</span>) <span class="comment"># 音量-</span></span><br><span class="line">d.press(<span class="string">&quot;volume_mute&quot;</span>) <span class="comment"># 静音</span></span><br><span class="line">d.press(<span class="string">&quot;camera&quot;</span>) <span class="comment"># 相机</span></span><br><span class="line">d.press(<span class="string">&quot;power&quot;</span>) <span class="comment">#电源键</span></span><br></pre></td></tr></table></figure></li><li><p>解锁屏幕</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d.unlock()</span><br><span class="line"><span class="comment"># 相当于</span></span><br><span class="line"><span class="comment"># 1. 发射活动:com.github.uiautomator.ACTION_IDENTIFY</span></span><br><span class="line"><span class="comment"># 2. 按home键</span></span><br></pre></td></tr></table></figure></li><li><p>手势与设备的交互</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单击屏幕</span></span><br><span class="line">d.click(x,y) <span class="comment"># x,y为点击坐标</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双击屏幕</span></span><br><span class="line">d.double_click(x,y)</span><br><span class="line">d.double_click(x,y,<span class="number">0.1</span>) <span class="comment"># 默认两个单击之间间隔时间为0.1秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 长按</span></span><br><span class="line">d.long_click(x,y)</span><br><span class="line">d.long_click(x,y,<span class="number">0.5</span>) <span class="comment"># 长按0.5秒（默认）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 滑动</span></span><br><span class="line">d.swipe(sx, sy, ex, ey)</span><br><span class="line">d.swipe(sx, sy, ex, ey, <span class="number">0.5</span>) <span class="comment">#滑动0.5s(default)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#拖动</span></span><br><span class="line">d.drag(sx, sy, ex, ey)</span><br><span class="line">d.drag(sx, sy, ex, ey, <span class="number">0.5</span>)<span class="comment">#拖动0.5s(default)</span></span><br><span class="line"><span class="comment"># 滑动点 多用于九宫格解锁，提前获取到每个点的相对坐标（这里支持百分比）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从点(x0, y0)滑到点(x1, y1)再滑到点(x2, y2)</span></span><br><span class="line"><span class="comment"># 两点之间的滑动速度是0.2秒</span></span><br><span class="line">d.swipe((x0, y0), (x1, y1), (x2, y2), <span class="number">0.2</span>)</span><br><span class="line"><span class="comment"># 注意：单击，滑动，拖动操作支持百分比位置值。例：</span></span><br><span class="line">d.long_click(<span class="number">0.5</span>, <span class="number">0.5</span>) 表示长按屏幕中心</span><br></pre></td></tr></table></figure></li><li><p>XPath</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检索方向</span></span><br><span class="line">d.orientation</span><br><span class="line"><span class="comment"># 检索方向。输出可以是 &quot;natural&quot; or &quot;left&quot; or &quot;right&quot; or &quot;upsidedown&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置方向</span></span><br><span class="line">d.set_orientation(<span class="string">&quot;l&quot;</span>) <span class="comment"># or &quot;left&quot;</span></span><br><span class="line">d.set_orientation(<span class="string">&quot;r&quot;</span>) <span class="comment"># or &quot;right&quot;</span></span><br><span class="line">d.set_orientation(<span class="string">&quot;n&quot;</span>) <span class="comment"># or &quot;natural&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#冻结/ 开启旋转</span></span><br><span class="line">d.freeze_rotation() <span class="comment"># 冻结旋转</span></span><br><span class="line">d.freeze_rotation(<span class="literal">False</span>) <span class="comment"># 开启旋转</span></span><br><span class="line"></span><br><span class="line"><span class="comment">########## 截图 ############</span></span><br><span class="line"><span class="comment"># 截图并保存到电脑上的一个文件中，需要Android&gt;=4.2。</span></span><br><span class="line">d.screenshot(<span class="string">&quot;home.jpg&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 得到PIL.Image格式的图像. 但你必须先安装pillow</span></span><br><span class="line">image = d.screenshot() <span class="comment"># default format=&quot;pillow&quot;</span></span><br><span class="line">image.save(<span class="string">&quot;home.jpg&quot;</span>) <span class="comment"># 或&#x27;home.png&#x27;，目前只支持png 和 jpg格式的图像</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 得到OpenCV的格式图像。当然，你需要numpy和cv2安装第一个</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">image = d.screenshot(<span class="built_in">format</span>=<span class="string">&#x27;opencv&#x27;</span>)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;home.jpg&#x27;</span>, image)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 获取原始JPEG数据</span></span><br><span class="line">imagebin = d.screenshot(<span class="built_in">format</span>=<span class="string">&#x27;raw&#x27;</span>)</span><br><span class="line"><span class="built_in">open</span>(<span class="string">&quot;some.jpg&quot;</span>, <span class="string">&quot;wb&quot;</span>).write(imagebin)</span><br><span class="line"></span><br><span class="line"><span class="comment">#############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转储UI层次结构</span></span><br><span class="line"><span class="comment"># get the UI hierarchy dump content (unicoded).（获取UI层次结构转储内容）</span></span><br><span class="line">d.dump_hierarchy()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开通知或快速设置</span></span><br><span class="line">d.open_notification() <span class="comment">#下拉打开通知栏</span></span><br><span class="line">d.open_quick_settings() <span class="comment">#下拉打开快速设置栏</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查特定的UI对象是否存在</span></span><br><span class="line">d(text=<span class="string">&quot;Settings&quot;</span>).exists <span class="comment"># 返回布尔值，如果存在则为True，否则为False</span></span><br><span class="line">d.exists(text=<span class="string">&quot;Settings&quot;</span>) <span class="comment"># 另一种写法</span></span><br><span class="line"><span class="comment"># 高级用法</span></span><br><span class="line">d(text=<span class="string">&quot;Settings&quot;</span>).exists(timeout=<span class="number">3</span>) <span class="comment"># 等待&#x27;Settings&#x27;在3秒钟出现</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取特定UI对象的信息</span></span><br><span class="line">d(text=<span class="string">&quot;Settings&quot;</span>).info</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取/设置/清除可编辑字段的文本(例如EditText小部件)</span></span><br><span class="line">d(text=<span class="string">&quot;Settings&quot;</span>).get_text() <span class="comment">#得到文本小部件</span></span><br><span class="line">d(text=<span class="string">&quot;Settings&quot;</span>).set_text(<span class="string">&quot;My text...&quot;</span>) <span class="comment">#设置文本</span></span><br><span class="line">d(text=<span class="string">&quot;Settings&quot;</span>).clear_text() <span class="comment">#清除文本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取Widget中心点</span></span><br><span class="line">d(text=<span class="string">&quot;Settings&quot;</span>).center()</span><br><span class="line"><span class="comment">#d(text=&quot;Settings&quot;).center(offset=(0, 0)) # 基准位置左前</span></span><br></pre></td></tr></table></figure></li><li><p>UI对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># text、resourceId、description、className、xpath、坐标</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行单击UI对象</span></span><br><span class="line"><span class="comment">#text定位单击</span></span><br><span class="line">d(text=<span class="string">&quot;Settings&quot;</span>).click()</span><br><span class="line">d(text=<span class="string">&quot;Settings&quot;</span>, className=<span class="string">&quot;android.widget.TextView&quot;</span>).click()</span><br><span class="line"></span><br><span class="line"><span class="comment">#resourceId定位单击</span></span><br><span class="line">d(resourceId=<span class="string">&quot;com.ruguoapp.jike:id/tv_title&quot;</span>, className=<span class="string">&quot;android.widget.TextView&quot;</span>).click() </span><br><span class="line"></span><br><span class="line"><span class="comment">#description定位单击</span></span><br><span class="line">d(description=<span class="string">&quot;设置&quot;</span>).click()</span><br><span class="line">d(description=<span class="string">&quot;设置&quot;</span>, className=<span class="string">&quot;android.widget.TextView&quot;</span>).click()</span><br><span class="line"></span><br><span class="line"><span class="comment">#className定位单击</span></span><br><span class="line">d(className=<span class="string">&quot;android.widget.TextView&quot;</span>).click()</span><br><span class="line"></span><br><span class="line"><span class="comment">#xpath定位单击</span></span><br><span class="line">d.xpath(<span class="string">&quot;//android.widget.FrameLayout[@index=&#x27;0&#x27;]/android.widget.LinearLayout[@index=&#x27;0&#x27;]&quot;</span>).click()</span><br><span class="line"></span><br><span class="line"><span class="comment">#坐标单击</span></span><br><span class="line">d.click(<span class="number">182</span>, <span class="number">1264</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待元素出现(最多10秒），出现后单击 </span></span><br><span class="line">d(text=<span class="string">&quot;Settings&quot;</span>).click(timeout=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 在10秒时点击，默认的超时0</span></span><br><span class="line">d(text=<span class="string">&#x27;Skip&#x27;</span>).click_exists(timeout=<span class="number">10.0</span>)</span><br><span class="line"><span class="comment"># 单击直到元素消失，返回布尔</span></span><br><span class="line">d(text=<span class="string">&quot;Skip&quot;</span>).click_gone(maxretry=<span class="number">10</span>, interval=<span class="number">1.0</span>) <span class="comment"># maxretry默认值10,interval默认值1.0</span></span><br><span class="line"><span class="comment"># 点击基准位置偏移</span></span><br><span class="line">d(text=<span class="string">&quot;Settings&quot;</span>).click(offset=(<span class="number">0.5</span>, <span class="number">0.5</span>)) <span class="comment"># 点击中心位置，同d(text=&quot;Settings&quot;).click()</span></span><br><span class="line">d(text=<span class="string">&quot;Settings&quot;</span>).click(offset=(<span class="number">0</span>, <span class="number">0</span>)) <span class="comment"># 点击左前位置</span></span><br><span class="line">d(text=<span class="string">&quot;Settings&quot;</span>).click(offset=(<span class="number">1</span>, <span class="number">1</span>)) <span class="comment"># 点击右下</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行双击UI对象</span></span><br><span class="line">d(text=<span class="string">&quot;设置&quot;</span>).double_click() <span class="comment"># 双击特定ui对象的中心</span></span><br><span class="line">d.double_click(x, y, <span class="number">0.1</span>) <span class="comment"># 两次单击之间的默认持续时间为0.1秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行长按UI对象</span></span><br><span class="line"><span class="comment"># 长按特定UI对象的中心</span></span><br><span class="line">d(text=<span class="string">&quot;Settings&quot;</span>).long_click()</span><br><span class="line">d.long_click(x, y, <span class="number">0.5</span>) <span class="comment"># 长按坐标位置0.5s默认</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将UI对象拖向另一个点或另一个UI对象</span></span><br><span class="line"><span class="comment"># Android&lt;4.3不能使用drag.</span></span><br><span class="line"><span class="comment"># 在0.5秒内将UI对象拖到屏幕点(x, y)</span></span><br><span class="line">d(text=<span class="string">&quot;Settings&quot;</span>).drag_to(x, y, duration=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将UI对象拖到另一个UI对象的中心位置，时间为0.25秒</span></span><br><span class="line">d(text=<span class="string">&quot;Settings&quot;</span>).drag_to(text=<span class="string">&quot;Clock&quot;</span>, duration=<span class="number">0.25</span>)</span><br></pre></td></tr></table></figure></li><li><p>example</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 等待10s</span></span><br><span class="line">d.xpath(<span class="string">&quot;//android.widget.TextView&quot;</span>).wait(<span class="number">10.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到并单击</span></span><br><span class="line">d.xpath(<span class="string">&quot;//*[@content-desc=&#x27;分享&#x27;]&quot;</span>).click()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否存在</span></span><br><span class="line"><span class="keyword">if</span> d.xpath(<span class="string">&quot;//android.widget.TextView[contains(@text, &#x27;Se&#x27;)]&quot;</span>).exists:</span><br><span class="line"> print(<span class="string">&quot;exists&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 获取所有文本视图文本、属性和中心点</span></span><br><span class="line"><span class="keyword">for</span> elem <span class="keyword">in</span> d.xpath(<span class="string">&quot;//android.widget.TextView&quot;</span>).<span class="built_in">all</span>():</span><br><span class="line"> print(<span class="string">&quot;Text:&quot;</span>, elem.text)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#获取视图文本</span></span><br><span class="line"><span class="keyword">for</span> elem <span class="keyword">in</span> d.xpath(<span class="string">&quot;//android.widget.TextView&quot;</span>).<span class="built_in">all</span>():</span><br><span class="line"> print(<span class="string">&quot;Attrib:&quot;</span>, elem.attrib)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#获取属性和中心点</span></span><br><span class="line"><span class="comment">#返回: (100, 200)</span></span><br><span class="line"><span class="keyword">for</span> elem <span class="keyword">in</span> d.xpath(<span class="string">&quot;//android.widget.TextView&quot;</span>).<span class="built_in">all</span>():</span><br><span class="line"> print(<span class="string">&quot;Position:&quot;</span>, elem.center())</span><br><span class="line"></span><br><span class="line"><span class="comment"># xpath常见用法：</span></span><br><span class="line"><span class="comment"># 所有元素</span></span><br><span class="line">//*</span><br><span class="line"></span><br><span class="line"><span class="comment"># resource-id包含login字符</span></span><br><span class="line">//*[contains(@resource-<span class="built_in">id</span>, <span class="string">&#x27;login&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按钮包含账号或帐号</span></span><br><span class="line">//android.widget.Button[contains(@text, <span class="string">&#x27;账号&#x27;</span>) <span class="keyword">or</span> contains(@text, <span class="string">&#x27;帐号&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有ImageView中的第二个</span></span><br><span class="line">(//android.widget.ImageView)[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有ImageView中的最后一个</span></span><br><span class="line">(//android.widget.ImageView)[last()]</span><br><span class="line"></span><br><span class="line"><span class="comment"># className包含ImageView</span></span><br><span class="line">//*[contains(name(), <span class="string">&quot;ImageView&quot;</span>)]</span><br></pre></td></tr></table></figure></li><li><p>其它</p><p>更多用法 <a href="https://github.com/openatx/uiautomator2">https://github.com/openatx/uiautomator2</a></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>简单理解栈溢出</title>
      <link href="2021/10/27/jian-dan-li-jie-zhan-yi-chu/"/>
      <url>2021/10/27/jian-dan-li-jie-zhan-yi-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="简单理解栈溢出"><a href="#简单理解栈溢出" class="headerlink" title="简单理解栈溢出"></a>简单理解栈溢出</h1><p>今天，发现了一个简单的程序（其实也不简单哈），首先，拿到了这个程序，是<code>exe</code>的，能在win运行，这点应该没问题，都是对未知的探索，然后，就点开了它，它的效果如下：</p><p><img src="helloworld.png" alt="helloworld"></p><p>这，？？？？，怎么全是“Hello Word”,盲猜，这个程序的作者写了一个无限的循环语句，当然，先关闭这个程序。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>把它拖到IDA中，反编译，查看一下它的伪代码，很快，就找到了Hello World的输出地方</p><p><img src="for.png" alt="for"></p><p>的确啊，很快可以看出，Hello Word是从<code>for循环</code>的<code>puts</code>函数输出的，可是，为啥它会无限输出，不应该当i的数值通过<code>i++</code>到7就结束了吗？为何不会是预期效果。</p><p>首先，理解一下程序，了解一下这个程序的目的，从根源上找到这个问题的原因。</p><ul><li>第一行声明了一个int类型的数组arr，声明里面有6个元素</li><li>第二行就是简单的声明了一个int类型的<code>i</code>,整型</li><li>第六至十一行代码的作用是逐个对数组arr的下标为0-5的元素，分别赋值为0,1,2,3,4,5</li><li>第12到17行，就是一个for循环的代码块，并且第12行对for的循环做出了条件限制，<ol><li>设置<code>i</code>的数值为<code>0</code></li><li>条件是<code>i</code>的大小 小于等于<code>7</code>的时候就执行循环语句</li><li>每一次循环以后对i的数值加一</li></ol></li><li>在for的代码块里，每一次循环，将数组的下标为i的元素的值改为0，并且输出Hello World</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>了解了这个函数的代码，可它到底有啥问题呢？</p><p>其实也很简单：</p><ul><li>它声明了一个数组，但是只设置了6个元素的容纳空间</li><li>在<code>for循环</code>里，i的数值能够通过<code>++i</code>到<code>6</code>,<code>7</code>，然后再对<code>arr</code>的第6，7的元素赋值为<code>0</code></li><li>问题就是<code>arr</code>数组的空间只有<code>6</code>个，对下标元素为1至6赋值为0没有问题，可是对第7个元素赋值呢</li><li>简单点来说，就是对一个不存在的元素赋值，并且设置为0，代码赋值成功了</li></ul><p>对于这个不存在的7号元素赋值，事实上是不存在的，赋值到哪里去了呢？</p><p>这也不难，答案是赋值给了i,就是说，用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">7</span>]=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>然而，结果却是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>要知道，这个<code>i</code>在第7次循环中，它的数值是<code>7</code>，在执行了<code>arr[i]=0</code>后，i就等于0了，然后i在下一次的for循环的判断<code>i&lt;=7</code>就满足条件，进而开启了下一次，再下一次的循环，输出无限的Hello World</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>解释一下原因</p><p>声明函数里面的变量，都是从高地址到低地址建立的，</p><p><img src="c.jpg" alt="c"></p><p>由此先后入栈，而题目的<code>arr</code>，<code>i</code>，也是遵循这个原理,不过数组声明了它的长度，也就是6个，可是for循环超出了6，用<code>arr[7]=0</code>向arr写入数据，但是写到了与arr相邻的i上面，从而表现出了数据从arr的高地址，溢出到了与arr相邻的低地址i，所以数据溢出后，i就变成了0，而不是arr的第7个元素变成了0。内存中没有第7个元素存在，与第6个元素相邻的就是它的下一个变量i对应的地址。</p><p><img src="adress.png" alt="adress"></p><p>图中的arr与i的地址是相邻的，所以数据超出了arr的6的范围，就溢出到了i</p><p>然后就是开始图示的无限的Hello World 的循环。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文如有问题，请指正。</p><p>程序来源：道格安全</p><p>本文by：<a href="mailto:&#113;&#105;&#117;&#x6b;&#x65;&#115;&#64;&#x38;&#x38;&#46;&#x63;&#111;&#x6d;">&#113;&#105;&#117;&#x6b;&#x65;&#115;&#64;&#x38;&#x38;&#46;&#x63;&#111;&#x6d;</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一招解决Android上Z3的安装问题</title>
      <link href="2021/10/26/yi-zhao-jie-jue-android-shang-z3-de-an-zhuang-wen-ti/"/>
      <url>2021/10/26/yi-zhao-jie-jue-android-shang-z3-de-an-zhuang-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近，我发现了一个神器，它能够解决很多的数学问题，简直是数学学生的福音，当然了，它的功能也十分强大，它可以解很多具有约束条件的方程，不仅支持简单的四则混合，同时也支持位域的运算求解方程。下面就讲讲其在Android上的安装方式。</p><h1 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h1><p>首先，在Android上，要想使用Z3，还真是不简单，肯定需要准备工具，termux,一般认为就是简单的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install z3-solver</span><br></pre></td></tr></table></figure><p>可能也可以，不过失败率高。</p><h1 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h1><p>首先用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;angr&#x2F;z3.git</span><br></pre></td></tr></table></figure><p>下载到本地，手动下载也可以。<br>然后，cd进入z3目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd z3</span><br></pre></td></tr></table></figure><p>接下来执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python scripts&#x2F;mk_make.py</span><br></pre></td></tr></table></figure><p>然后，经过漫长的等待</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd build; make</span><br></pre></td></tr></table></figure><p>又是等待，接下来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>手机没有root,就用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proot make install</span><br></pre></td></tr></table></figure><blockquote><p>没root，需要下载 proot</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg install proot</span><br></pre></td></tr></table></figure><p>安装完成后，就可以输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python</span><br></pre></td></tr></table></figure><p>然后输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from z3 import *</span><br></pre></td></tr></table></figure><p>如果不报错，你就成功了<br>本教程Linux也适用。</p><p>z3项目地址：<a href="https://github.com/Z3Prover/z3">https://github.com/Z3Prover/z3</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ctf re入门</title>
      <link href="2021/10/08/ctf-ru-men/"/>
      <url>2021/10/08/ctf-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>一般来说，我们拿到一个ctf的题，就是为了得到它的flag,为了它，RE做安全的十分努力，百分艰辛，就为了得到它。</p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="试运行"><a href="#试运行" class="headerlink" title="试运行"></a>试运行</h2><p>有了ctf的re的题目，ctfer有一套经典的流程，双击打开xxx.exe开始你的find flag之旅，一般来说就会提示<br><img src="2.png" alt="Hi,CTFer"><br>，它的意思是说，你好，CTFer,输入你的flag,那么你就可以输入，不用说，几乎都是you are wrong<br><img src="1.png" alt="you are wrong"><br>所以，为了不错，得到正确的答案flag，就必须选择理解它，信任它。它自然会给你答案。</p><h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><p>相信它，自然就是把它扔进ida,进行逆向分析。下面给出简单的几个exe的ctf题。</p><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>你将会得到<br><img src="T1.png" alt="T1"><br>看着T1的伪代码，一眼就可以看出这个题的flag,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;YOU_FIND_IT&#125;</span><br></pre></td></tr></table></figure><p>再执行流程，双击打开T1.exe,输入你的flag,就可以得到you are right，就这么简单。</p><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>拿道题流程完毕，ida,就又可以得到<br><img src="T2.png" alt="T2"><br>可以看出，用户输入一个str1的字符串，然后利用for循环进行加i操作，最后将新得到的str1和“gmbh|ZPV`GJOE`JU`IBIB~”进行比较，如果相同，就是you are right,不同就是you are wrong。</p><ul><li><p>思路: 对“gmbh|ZPV<code>GJOE</code>JU`IBIB~”进行逐个减去i，即可得到答案。</p></li><li><p>解题:<br>可以用C语言写一个脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">char a[50];</span><br><span class="line">scanf(&quot;%s&quot;,a);</span><br><span class="line">for(int i&#x3D;0;i&lt;strlen(a);++i)&#123;</span><br><span class="line">--a[i];</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%s-%d&quot;,a,strlen(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入”gmbh|ZPV<code>GJOE</code>JU`IBIB~”得到答案</p></li></ul><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>拿题流程完毕，ida可以得到<br><img src="T3.png" alt="T3"><br>对已知的函数命名，可以看出，T3是对T2的一次升级，加入了异或的算法。</p><ul><li><p>题目: 用scanf输入str1 -&gt; 在  for 中 将str1的每一个字符与其下标异或 -&gt; 将得到的str1与 str2比较</p></li><li><p>知识点：异或运算是一个二元运算，在C语言中的运算符号为 ^,规则为   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A ^ B &#x3D; C</span><br><span class="line">C ^ B &#x3D; A</span><br><span class="line">C ^ A &#x3D; B</span><br></pre></td></tr></table></figure><p>也就是说:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">明文 ^ 密钥 &#x3D; 密文</span><br><span class="line">密文 ^ 密钥 &#x3D; 明文</span><br></pre></td></tr></table></figure><p>所以，解题就是再对str2进行一次异或运算</p></li><li><p>str2</p><blockquote><p>双击str2会跳转到它的数据定义窗口<img src="T3-a.png" alt="str2">，从’66h’,’6Dh’到’55h’,’68h’,’0’的字符串数据，可以通过LazyIDA插件转换为byte字节。str2的实际数据是</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0x66, 0x6D, 0x63, 0x64, 0x7F, 0x5C, 0x49, 0x52, 0x57, 0x4F, 0x43, 0x45, 0x48, 0x52, 0x47, 0x5B, 0x4F, 0x59, 0x53, 0x5B, 0x55, 0x68, 0x00]</span><br></pre></td></tr></table></figure></li><li><p>解题<br>C语言的脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">char a[]&#x3D;&#123;0x66, 0x6D, 0x63, 0x64, 0x7F, 0x5C, 0x49, 0x52,0x57, 0x4F, 0x43, 0x45, 0x48, 0x52, 0x47, 0x5B, 0x4F, 0x59, 0x53, 0x5B, 0x55, 0x68, 0x00&#125;;</span><br><span class="line">for(int i&#x3D;0;i&lt;strlen(a);++i)&#123;</span><br><span class="line">      a[i]^&#x3D;i;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%s&quot;,a);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行就可以得到flag</p></li></ul><h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>放进ida之后，可以得到<br><img src="T4.png" alt="T4"><br>T4.exe在T3.exe基础上加上了一个新的函数处理sub_455A94( )</p><ul><li><p>题目：输入str -&gt; 对str的字符串进行异或 -&gt; 再对整个字符串sub_455A94( )处理 -&gt;与 ”Zm1jZH9cSVJXT0NFSFJHW09ZU1tVaA==”比较</p></li><li><p>sub_455A94 </p><blockquote><p>这是一个啥函数，不知道。但是我们可以了解。双击函数看到<img src="T4-a.png" alt="sub_455A94 ()">再次双击函数sub_45A3F0，这是对sub_45A3F0 的封装，进入底层函数，<img src="T4-b.png" alt="底层函数">该函数多次引用off_529000 ,双击可以跳转到其资源地址,可以把鼠标放在图示位置<img src="T4-c.png" alt="字符串表">可以看到是字符表，推敲为base64,所以sub_455A94()为base64加密处理</p></blockquote></li><li><p>解题思路: 对“Zm1jZH9cSVJXT0NFSFJHW09ZU1tVaA==”进行base64解码 -&gt; 再进行异或解密 -&gt; flag</p></li><li><p>解题代码 （C语言）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">char a[]&#x3D;&quot;fmcd\IRWOCEHRG[OYS[Uh&quot;;&#x2F;&#x2F;对“Zm1jZH9cSVJXT0NFSFJHW09ZU1tVaA&#x3D;&#x3D;”base64解密后的字符串</span><br><span class="line">for(int i&#x3D;0;i&lt;strlen(a);++i)&#123;</span><br><span class="line">     a[i]^&#x3D;i;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%s&quot;,a);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="T5"><a href="#T5" class="headerlink" title="T5"></a>T5</h3><p>直接得到如下<br><img src="T5.png" alt="T5"><br>Amazing,T5和T4竟然差不多，直接按照T4的方法得到flag,你就会得到”you are wrong”<img src="1.png" alt="wrong">这是因为T5和T4还是有不同之处的。</p><ul><li><p>不同之处:在sub_455A94()函数中，依旧是sub_45A3F0(),也使用了off_529000 ,不过内部，并没有使用标准字母表，而是图示<img src="T5-a.png" alt="改动了的字母表">这属于魔改字母表。</p></li><li><p>base64</p><blockquote><p>base64一般是使用的标准字母表计算出来的字符串</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;</span><br></pre></td></tr></table></figure><p>但是，标准字母表的字母位置和改动了的字母位置下标应该一样。</p></li><li><p>替换base64：在表中应该如下替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">待替换  Wj1gWE9xPSGUQ0KCPCGET09WR1qSzZ</span><br><span class="line">魔改表  ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+&#x2F;</span><br><span class="line">标准表  ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;</span><br><span class="line">已替换  Zm1jZH9cSVJXT0NFSFJHW09ZU1tVaA</span><br></pre></td></tr></table></figure><p>也可以写一个Python脚本替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import base64;</span><br><span class="line">v&#x3D;&quot;Wj1gWE9xPSGUQ0KCPCGET09WR1qSzZ&quot;;</span><br><span class="line">a&#x3D;&quot;ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+&#x2F;&quot;;</span><br><span class="line">b&#x3D;&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;&quot;;</span><br><span class="line">r&#x3D;&quot;&quot;;</span><br><span class="line">for i in v:</span><br><span class="line">    r+&#x3D;b[a.find(i)];</span><br><span class="line">print(r); #结果是Zm1jZH9cSVJXT0NFSFJHW09ZU1tVaA</span><br></pre></td></tr></table></figure><p>替换完成后，就可以使用标准的base64进行解码</p></li><li><p>C语言解题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">char a[]&#x3D;&quot;fmcd\IRWOCEHRG[OYS[Uh&quot; ;&#x2F;&#x2F;base64解码后的结果</span><br><span class="line">for(int i&#x3D;0;i&lt;strlen(a);++i)&#123;</span><br><span class="line">      a[i]^&#x3D;i;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%s&quot;,a);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="T6"><a href="#T6" class="headerlink" title="T6"></a>T6</h3><p>直接IDA,得到<br><img src="T6.png" alt="T6">看到伪代码一大堆，不过，也不用怕，可以看到str2为用户输入，将str2和str1作比较，str1是通过一系列代码运算出来的，这么复杂，怎么办？其实很简单，既然是计算出来的，那就可以把计算表达式抄下来，写一个C程序，把str1用printf出来即可。</p><p>不过，IDA这么高级，当然也可以动态调试。</p><ul><li>解题:<br>在ida的菜单栏里面找到debugger-&gt;select debugger<br><img src="T6-a.png" alt="image"><br>选择local windows debugger<br><img src="T6-b.png" alt="image"><br>在代码行的前面标记小蓝点，就表示在这里需要运行时停下来调试<br><img src="T6-c.png" alt="image"><br>在菜单栏-&gt;debugger-&gt;start progress开始调试运行了<br><img src="T6-d.png" alt="image"><br>后面会跳出命令提示框，随便输入点东西，回车继续运行，停止后，将鼠标移动到str1上面，就可以看见程序运行时的结果了。<br><img src="T6-e.png" alt="image"><br>你的flag就是它了。</li></ul><h2 id="完整的文件下载"><a href="#完整的文件下载" class="headerlink" title="完整的文件下载"></a>完整的文件下载</h2><p><a href="T.rar">下载地址</a>:<a href="T.rar">点我下载</a></p><p>本文如有不对，请指正</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git for windows</title>
      <link href="2021/10/05/git-for-windows/"/>
      <url>2021/10/05/git-for-windows/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Git是一个分布式管理的软件，功能十分强大，在windows平台上，在安装的时候，便可以将其配置完毕。本文详细介绍了一下。本文Git for windows 版本是2.33.0.2</p><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>下载一般有两个渠道</p><ul><li>渠道1： <a href="https://gitforwindows.org/">https://gitforwindows.org/</a></li><li>渠道2：淘宝镜像 <a href="https://npm.taobao.org/mirrors/git-for-windows/">https://npm.taobao.org/mirrors/git-for-windows/</a></li></ul><p>下载exe文件直接运行就可以安装完成</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>下载软件之后，然后就双击打开，就开始了开始向导，这是一个协议，同意就”next“<br><img src="1.png" alt="开始向导"><br>选择一个Git软件的安装目录，建议选择除C盘以外的盘符，以免以后C盘文件过多，导致不必要的卡钝。<br><img src="2.png" alt="选择安装目录"><br>下一步就可以选择你要安装的组件，按照需求选择就可以了，一般就直接”next”<br><img src="3.png" alt="选择组件"><br>选择是否创建开始菜单的文件夹，或者选择一个开始菜单的文件夹创建Git软件的快捷方式，当然也可以不选择创建开始菜单文件<br><img src="4.png" alt="开始菜单"><br>在这里可以选择你比较喜欢的编辑器进行编辑，作为Git的默认编辑器，选择比较多，比如，vim,trapra等等。<br><img src="5.png" alt="默认编辑器"><br>这一步是选择调整在一个新的仓库起初默认的分支名字（git init），一般选择默认就可以，let Git decide,就直接“next”<br><img src="6.png" alt="默认init"><br>下面就是布置环境变量了，如此设置后，在以后的windows命令提示符里可以使用，进行git操作，不然手动设置，很麻烦。Git比较推荐的是设置windows的命令提示符和第三方软件也可以使用。<br><img src="7.png" alt="环境变量"><br>在这个版本之下，提供了一种新的ssh的链接方式，这里是和Git自带的ssh软件进行选择，使ssh连接更安全。嫌麻烦，也可next<br><img src="8.png" alt="ssh"><br>配置行结束转换Git应该如何处理文本文件中的行尾.</p><ul><li>签出Windows样式，提交Unix样式的行尾</li><li>当签出文本传单时，git将不执行任何转换。</li><li>按-原样签出，按-原样提交</li></ul><p>next也即可<br><img src="9.png" alt="提交行为"><br>选择默认第一个即可，继续“下一步”<br><img src="10.png" alt="helper"><br>下面步骤比较多，反正直接next即可，有需求的也可以仔细浏览操作提示，做出你最希望的选择。</p><p><img src="11.png" alt="image"><br><img src="12.png" alt="image"><br><img src="13.png" alt="image"><br><img src="14.png" alt="image"><br><img src="15.png" alt="image"><br>这一步，当然不用next了，你只需等待几十秒钟就可以迎接你的git分布式管理了。<br><img src="16.png" alt="image"><br>到了这里，基本上，你已经完成了Git的一系列的安装操作<br><img src="17.png" alt="安装完成"></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>可以参考</p><ul><li><p><a href="http://www.ruanyifeng.com/blog/2018/10/git-internals.html">阮一峰博客</a></p></li><li><p><a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git">Git中文文档</a></p></li><li><p><a href="https://www.topgoer.com/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/Git%E5%AE%89%E8%A3%85.html">https://www.topgoer.com</a></p></li><li><p><a href="https://kuangtant.gitee.io/2021/08/28/ge-ping-tai-an-zhuang-git/">各平台安装Git</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言对数组指针的理解</title>
      <link href="2021/09/28/c-yu-yan-dui-shu-zu-zhi-zhen-de-li-jie/"/>
      <url>2021/09/28/c-yu-yan-dui-shu-zu-zhi-zhen-de-li-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C语言有很多的知识，其中一个就是关于数组指针的问题，对于一些刚学C语言的萌新来说，C语言的数组指针是一个问题。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>数组（Array）是一系列具有相同类型的数据的集合，每一份数据叫做一个数组元素（Element）。而且数组在内存中只占一块内存，并且每一个元素是连续排列的。</p><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>一般来说，C语言创建数组只需要两个条件：</p><ol><li>指明数组的类型</li><li>指明数组的长度，不能越界使用。</li></ol><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 1024 ; int arr[5] &#x3D; &#123;1,2,3,4,5&#125;; &#x2F;&#x2F; 完全初始化</span><br><span class="line">  int arr1[] &#x3D; &#123;1,2,3,4,5,6,7,8,9,10&#125; &#x2F;&#x2F; 正确，定义的时候并没有确定大小， 初始化后才确定的大小 </span><br><span class="line">  arr2 &#x3D; &#123;1,2,3,4,5,&#125;&#x2F;&#x2F; 不可行， 数组只有在初始化的时候可以统一赋值 </span><br><span class="line">  int arr2 [5] &#x3D; &#123;1,2,3,4,5,6,7&#125;; &#x2F;&#x2F; 语法上可以，但是逻辑上不允许， 涉嫌越界</span><br><span class="line">  int arr3[50] &#x3D; &#123;1,2,3,4,5&#125;; &#x2F;&#x2F; 不完全初始化 ， 没有初始化部分自动填充0 </span><br></pre></td></tr></table></figure><h2 id="对数组名称的理解"><a href="#对数组名称的理解" class="headerlink" title="对数组名称的理解"></a>对数组名称的理解</h2><p>总的来说，环境不同，数组名称的意义就不同。</p><ol><li>表示整个数组</li></ol><ul><li><p>在定义的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int arr[3]&#x3D;&#123;0,1,2&#125;</span><br></pre></td></tr></table></figure></li><li><p>在sizeof语句中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int len&#x3D;sizeof(arr)&#x2F;sizeof(int); &#x2F;&#x2F;求长度</span><br></pre></td></tr></table></figure></li><li><p>在取地址&amp;arr时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *p&#x3D;&amp;arr;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li> 在其余时候都表示数组中第一个元素的地址。</li></ol><blockquote><p>当数组名确定后，数组名就是一个地址常量，不能更改。但可以把数组赋值给指针。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *p;</span><br><span class="line">p&#x3D;arr;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几小时带你学会Python-之-1</title>
      <link href="2021/09/25/ji-xiao-shi-dai-ni-xue-hui-python-zhi-1/"/>
      <url>2021/09/25/ji-xiao-shi-dai-ni-xue-hui-python-zhi-1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网络上有许多的语言，那么最容易上手的是什么呢？我认为是Python,用几个小时小白也能学会，而且，Python是一种很好的工具，编写起来十分简单，达到目的的效果快，比如一些的网络安全大赛的解题很多都是使用的Python，大学生，如果平时没事，写写Python脚本，抢抢课，签签到，你还在睡懒觉，别人没抢到，你啥都做完了。所以，Python是一种神奇的存在。（本教程为Python2脚本）</p><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><p>Python的语法十分简单，易于维护。下面展示我的第一个Python脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print (&quot;Hello, Python!&quot;)</span><br></pre></td></tr></table></figure><p>只需要在交互式命令窗口输入命令运行即可。看到结果是否很兴奋。</p><h2 id="一行代码"><a href="#一行代码" class="headerlink" title="一行代码"></a>一行代码</h2><p>Python 可以同一行显示多条语句，方法是用分号 ; 分开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print (&#39;hello&#39;);print (&#39;python&#39;);</span><br><span class="line">hello</span><br><span class="line">python</span><br></pre></td></tr></table></figure><h2 id="保留关键词"><a href="#保留关键词" class="headerlink" title="保留关键词"></a>保留关键词</h2><p>Python有的词不能作为变量名，被Python保留了下来，它们是</p><table><thead><tr><th align="center">保留的</th><th align="center">关键词</th><th align="center">不能用</th></tr></thead><tbody><tr><td align="center">and</td><td align="center">exec</td><td align="center">not</td></tr><tr><td align="center">assert</td><td align="center">finally</td><td align="center">or</td></tr><tr><td align="center">break</td><td align="center">for</td><td align="center">pass</td></tr><tr><td align="center">class</td><td align="center">from</td><td align="center">print</td></tr><tr><td align="center">continue</td><td align="center">global</td><td align="center">raise</td></tr><tr><td align="center">def</td><td align="center">if</td><td align="center">return</td></tr><tr><td align="center">del</td><td align="center">import</td><td align="center">try</td></tr><tr><td align="center">elif</td><td align="center">in</td><td align="center">while</td></tr><tr><td align="center">else</td><td align="center">is</td><td align="center">with</td></tr><tr><td align="center">except</td><td align="center">lambda</td><td align="center">yield</td></tr></tbody></table><h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><p>Python和其他语言的最大区别是不用{}包围代码块，而是用严格的缩进要求的，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if True:</span><br><span class="line">    print (&quot;True&quot;)</span><br><span class="line">else:</span><br><span class="line">    print (&quot;False&quot;)</span><br></pre></td></tr></table></figure><p>就是代码必须保证它的空格数相同。否则会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if True:</span><br><span class="line">    print (&quot;True&quot;)</span><br><span class="line">else:</span><br><span class="line">    print (&quot;False&quot;)</span><br><span class="line"> print(&#39;other&#39;)</span><br></pre></td></tr></table></figure><p>以上的代码会报错，最后一个print没有严格的缩进空格，以后大家注意点就行。</p><h2 id="一句多行"><a href="#一句多行" class="headerlink" title="一句多行"></a>一句多行</h2><p>如果是多行的代码，可以使用反斜杠连接，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; b + \\</span><br><span class="line">    c + \\</span><br><span class="line">    d</span><br></pre></td></tr></table></figure><p>语句中包含()[]{}就不需要\连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers &#x3D; [1 ,2 ,3 , 4 ,5 ,</span><br><span class="line">           6 ,7 ,8 ,9 ]</span><br></pre></td></tr></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Python的注释采用#,’’’,”””进行注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">print(&#39;Hi Python&#39;)  #我是注释，不会被执行</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">我们是多行注释</span><br><span class="line">注释</span><br><span class="line">注释</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">print(&#39;ha ha&#39;)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">我们也是多行注释</span><br><span class="line">注释</span><br><span class="line">注释</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h2 id="中文处理"><a href="#中文处理" class="headerlink" title="中文处理"></a>中文处理</h2><p>如果Python脚本遇到中文，程序会报错，需要在文件开头声明编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">print(&#39;哈哈&#39;)</span><br></pre></td></tr></table></figure><h2 id="等待用户输入"><a href="#等待用户输入" class="headerlink" title="等待用户输入"></a>等待用户输入</h2><p>在Python中\n表示换行，raw_input函数，等待用户输入，然后按下enter退出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raw_input(&quot;按下 enter 键退出，其他任意键显示...\n&quot;)</span><br></pre></td></tr></table></figure><h2 id="print函数"><a href="#print函数" class="headerlink" title="print函数"></a>print函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x&#x3D;&quot;a&quot;</span><br><span class="line">y&#x3D;&quot;b&quot;</span><br><span class="line"># 换行输出</span><br><span class="line">print x</span><br><span class="line">print y</span><br><span class="line"></span><br><span class="line">print &#39;---------&#39;</span><br><span class="line"># 不换行输出</span><br><span class="line">print x,</span><br><span class="line">print y,</span><br><span class="line"></span><br><span class="line"># 不换行输出</span><br><span class="line">print x,y</span><br></pre></td></tr></table></figure><p>结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a </span><br><span class="line">b</span><br><span class="line">-------</span><br><span class="line">a b a b</span><br></pre></td></tr></table></figure><h1 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h1><p>Python也有变量，也要类型，不过编写简单。也是采用”变量名=变量值”的方式，就是将变量值赋值给变量名。<br>Python标准变量有以下类型</p><ul><li>Numbers（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Dictionary（字典）</li></ul><h2 id="赋值变量"><a href="#赋值变量" class="headerlink" title="赋值变量"></a>赋值变量</h2><h3 id="单个赋值"><a href="#单个赋值" class="headerlink" title="单个赋值"></a>单个赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 1 #这是整型</span><br><span class="line">b &#x3D; 2.0 #浮点</span><br><span class="line">c &#x3D; &quot;3&quot; #字符串</span><br></pre></td></tr></table></figure><h3 id="多个赋值"><a href="#多个赋值" class="headerlink" title="多个赋值"></a>多个赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; b &#x3D; c &#x3D; 1</span><br></pre></td></tr></table></figure><p>a,b,c都被赋值为了1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a , b , c &#x3D; 1 , 2.0 , &quot;ha ha&quot;</span><br></pre></td></tr></table></figure><p>a,b,c分别被赋值为了整型1,浮点2.0,字符串ha ha</p><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>数字赋值时，number对象会被创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 1</span><br><span class="line">b &#x3D; 2</span><br><span class="line">c &#x3D; 3</span><br></pre></td></tr></table></figure><p>del可以删除对象的引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">del a</span><br><span class="line">del b , c</span><br></pre></td></tr></table></figure><p>数字有四种类型</p><ul><li>int（有符号整型）</li><li>long（长整型，也可以代表八进制和十六进制）</li><li>float（浮点型）</li><li>complex（复数）</li></ul><p>实例</p><table><thead><tr><th align="center">int</th><th align="center">long</th><th align="center">float</th><th align="center">complex</th></tr></thead><tbody><tr><td align="center">10</td><td align="center">51924361L</td><td align="center">0.0</td><td align="center">3.14j</td></tr><tr><td align="center">100</td><td align="center">-0x19323L</td><td align="center">15.20</td><td align="center">45.j</td></tr><tr><td align="center">-786</td><td align="center">0122L</td><td align="center">-21.9</td><td align="center">9.322e-36j</td></tr><tr><td align="center">080</td><td align="center">0xDEFABCECBDAECBFBAEl</td><td align="center">32.3e+18</td><td align="center">.876j</td></tr><tr><td align="center">-0490</td><td align="center">535633629843L</td><td align="center">-90.</td><td align="center">-.6545+0J</td></tr><tr><td align="center">-0x260</td><td align="center">-052318172735L</td><td align="center">-32.54e100</td><td align="center">3e+26J</td></tr><tr><td align="center">0x69</td><td align="center">-4721885298529L</td><td align="center">70.2E-12</td><td align="center">4.53e-7j</td></tr></tbody></table><blockquote><p>注意：long 类型只存在于 Python2.X 版本中，在 2.2 以后的版本中，int 类型数据溢出后会自动转为long类型。在 Python3.X 版本中 long 类型被移除，使用 int 替代</p></blockquote><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串就是字母，数字，或者其他字符组成的一串文字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; &quot;我是字符串&quot;</span><br></pre></td></tr></table></figure><p>其中，它们的下标对应关系</p><table><thead><tr><th align="center">我</th><th align="center">是</th><th align="center">字</th><th align="center">符</th><th align="center">串</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td></tr><tr><td align="center">-5</td><td align="center">-4</td><td align="center">-3</td><td align="center">-2</td><td align="center">-1</td></tr></tbody></table><p>可以通过下标访问字符串。比如语法[头下标:尾下标]，但是“有头无尾”，就是包括下标头，不包括下标尾。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; &#39;我是字符串&#39;</span><br><span class="line">b &#x3D; a[1:3]</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是字</span><br></pre></td></tr></table></figure><p>其他例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str &#x3D; &#39;Hello World!&#39;</span><br><span class="line"> </span><br><span class="line">print str           # 输出完整字符串</span><br><span class="line">print str[0]        # 输出字符串中的第一个字符</span><br><span class="line">print str[2:5]      # 输出字符串中第三个至第六个之间的字符串</span><br><span class="line">print str[2:]       # 输出从第三个字符开始的字符串</span><br><span class="line">print str * 2       # 输出字符串两次</span><br><span class="line">print str + &quot;TEST&quot;  # 输出连接的字符串</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br><span class="line">H</span><br><span class="line">llo</span><br><span class="line">llo World!</span><br><span class="line">Hello World!Hello World!</span><br><span class="line">Hello World!TEST</span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表使用[]包围，索引类似于Python字符串，从左到右为0至+∞，从左往右为-1到-∞,支持[头下标：尾下标]用法。并且支持运算*和+</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; [&#39;一&#39;,&#39;二&#39;,&#39;三&#39;,&#39;四&#39;,&#39;五&#39;]  #这里定义了一个列表</span><br><span class="line">b &#x3D;[5,2.5,155]  #这也是一个列表</span><br><span class="line">print a               # 输出完整列表</span><br><span class="line">print a[0]            # 输出列表的第一个元素</span><br><span class="line">print a[1:3]          # 输出第二个至第三个元素 </span><br><span class="line">print a[2:]           # 输出从第三个开始至列表末尾的所有元素</span><br><span class="line">print a * 2       # 输出列表两次</span><br><span class="line">print a + b    # 打印组合的列表</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&#39;一&#39;,&#39;二&#39;,&#39;三&#39;,&#39;四&#39;,&#39;五&#39;]</span><br><span class="line">一</span><br><span class="line">[&quot;二&quot;,&quot;三&quot;]</span><br><span class="line">[&#39;三&#39;,&#39;四&#39;,&#39;五&#39;]</span><br><span class="line">[&#39;一&#39;,&#39;二&#39;,&#39;三&#39;,&#39;四&#39;,&#39;五&#39;,&#39;一&#39;,&#39;二&#39;,&#39;三&#39;,&#39;四&#39;,&#39;五&#39;]</span><br><span class="line">[&#39;一&#39;,&#39;二&#39;,&#39;三&#39;,&#39;四&#39;,&#39;五&#39;,5,2.5,155]</span><br></pre></td></tr></table></figure><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>和列表用法相似，是使用()包围，最大不同是，列表元素可修改，而元组不可修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; (1,2,3,4) #我是一个元组</span><br><span class="line">b &#x3D; [1,2,3,4] #我是一个列表</span><br><span class="line">print a[0],b[0] #输出1  1</span><br><span class="line">a[0]&#x3D;100  #a是元组，不能修改，会报错</span><br><span class="line">b[0]&#x3D;100  #b是列表，正常修改为[100,2,3,4]</span><br></pre></td></tr></table></figure><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典，听其名，便可以知道其高级，能够应用查阅。使用{}定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D;&#123;&#125; #定义一个空字典</span><br><span class="line">a[&quot;she&quot;]&#x3D;&quot;she is girl&quot;</span><br><span class="line">a[&quot;he&quot;]&#x3D;&quot;he is boy&quot;</span><br><span class="line"></span><br><span class="line">b&#x3D;&#123;&quot;你&quot;:&quot;you&quot;,&quot;我&quot;:&quot;I&quot;,&quot;他&quot;:555&#125;</span><br><span class="line"></span><br><span class="line">print a #输出a字典</span><br><span class="line">print b[&#39;你&#39;]  在b字典中查询&#39;你&#39;的值</span><br><span class="line">print b.keys() #输出所有键,列表</span><br><span class="line">print b.values() #输出所有值，列表</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;she&quot;:&quot;she is girl&quot;,&quot;he&quot;:&quot;he is boy&quot;&#125;</span><br><span class="line">you</span><br><span class="line">[&quot;你&quot;,&quot;我&quot;,&quot;他&quot;]</span><br><span class="line">[&quot;you&quot;,&quot;I&quot;,555]</span><br></pre></td></tr></table></figure><h2 id="数据的类型是可以转换的"><a href="#数据的类型是可以转换的" class="headerlink" title="数据的类型是可以转换的"></a>数据的类型是可以转换的</h2><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">int(x [,base])</td><td align="center">将x转换为一个整数</td></tr><tr><td align="center">long(x [,base] )</td><td align="center">将x转换为一个长整数</td></tr><tr><td align="center">float(x)</td><td align="center">将x转换到一个浮点数</td></tr><tr><td align="center">complex(real [,imag])</td><td align="center">创建一个复数</td></tr><tr><td align="center">str(x)</td><td align="center">将对象 x 转换为字符串</td></tr><tr><td align="center">repr(x)</td><td align="center">将对象 x 转换为表达式字符串</td></tr><tr><td align="center">eval(str)</td><td align="center">用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td align="center">tuple(s)</td><td align="center">将序列 s 转换为一个元组</td></tr><tr><td align="center">list(s)</td><td align="center">将序列 s 转换为一个列表</td></tr><tr><td align="center">set(s)</td><td align="center">转换为可变集合</td></tr><tr><td align="center">dict(d)</td><td align="center">创建一个字典。d 必须是一个序列 (key,value)元组。</td></tr><tr><td align="center">frozenset(s)</td><td align="center">转换为不可变集合</td></tr><tr><td align="center">chr(x)</td><td align="center">将一个整数转换为一个字符</td></tr><tr><td align="center">unichr(x)</td><td align="center">将一个整数转换为Unicode字符</td></tr><tr><td align="center">ord(x)</td><td align="center">将一个字符转换为它的整数值</td></tr><tr><td align="center">hex(x)</td><td align="center">将一个整数转换为一个十六进制字符串</td></tr><tr><td align="center">oct(x)</td><td align="center">将一个整数转换为一个八进制字符串</td></tr><tr><td align="center">以上函数可以返回一个新对象，作为转换后的值。</td><td align="center"></td></tr></tbody></table><p>更多相关信息可以了解</p><ul><li>Python中文文档<a href="https://m.runoob.com/manual/pythontutorial/docs/html/">Python2.7版 入门指南</a></li><li>Python官方文档<a href="https://www.python.org/doc/">https://www.python.org/doc/</a></li><li>Python 官网 <a href="https://www.python.org/">https://www.python.org</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python2 </tag>
            
            <tag> Python </tag>
            
            <tag> 脚本 </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android的java运行方案</title>
      <link href="2021/09/17/android-de-java-yun-xing-fang-an/"/>
      <url>2021/09/17/android-de-java-yun-xing-fang-an/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>java语言早已经被各大厂商，集团，学校，社会等运用，并且发挥了巨大的作用，一般来说，java具有可移植的特性，能够被广泛的运用到各大平台，在Windows,Linux,Mac等平台已经常而常之，但是在Android环境运行如何呢？</p><h1 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h1><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>既然Linux可以使用java环境的JDK包，那么在Android上可以进行使用，软件Termux能够完成这一设想。</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>官方为我们提供了JDK,便可以直接使用</p><ol><li><p>查询官方的JDK</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg search jdk</span><br></pre></td></tr></table></figure></li><li><p>根据提示进行安装官方提供的JDK版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg install openjdk-17</span><br></pre></td></tr></table></figure></li><li><p>最后可以检查安装是否完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure></li></ol><h2 id="运行java"><a href="#运行java" class="headerlink" title="运行java"></a>运行java</h2><ul><li><p>如果你有写好的java文件，可以通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd storage&#x2F;shared&#x2F;你的文件目录</span><br></pre></td></tr></table></figure></li><li><p>然后进行编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac 你的java文件名.java</span><br></pre></td></tr></table></figure></li><li><p>最后运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java 你的文件名</span><br></pre></td></tr></table></figure></li></ul><h1 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h1><h2 id="工具-1"><a href="#工具-1" class="headerlink" title="工具"></a>工具</h2><p>在Android平台,有一款集成java的开发环境的软件，它就是AIDE,这个操作就比较简单，下载软件安装即可。</p><h2 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h2><ol><li>在Google Play或者其它运用商店搜索“AIDE”并下载。</li><li>在你的项目目录新建JAVA程序</li><li>书写你的java代码</li><li>点击右上角的运行即可调试</li></ol><h1 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h1><h2 id="工具-2"><a href="#工具-2" class="headerlink" title="工具"></a>工具</h2><p>在移动端上，可以利用浏览器在线运行java程序，可以自行搜索<a href="https://baidu.com/s?word=%E5%9C%A8%E7%BA%BFjava%E8%BF%90%E8%A1%8C">在线java运行</a></p><h2 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h2><ul><li><p>在线<a href="https://www.bejson.com/runcode/java/">BeJson</a>工具：<a href="https://www.bejson.com/runcode/java/">https://www.bejson.com/runcode/java/</a></p></li><li><p><a href="https://c.runoob.com/compile/10/">菜鸟工具</a>运行Java<br>：<a href="https://c.runoob.com/compile/10/">https://c.runoob.com/compile/10/</a></p></li><li><p><a href="https://tool.lu/coderunner">Tool.lu</a>网站：<a href="https://tool.lu/coderunner">https://tool.lu/coderunner</a></p></li></ul><p>其它好用的工具可<a href="https://baidu.com/">百度一下</a>：<a href="https://baidu.com/s?word=%E5%9C%A8%E7%BA%BFjava%E8%BF%90%E8%A1%8C">在线java运行</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 编译器 </tag>
            
            <tag> Termux </tag>
            
            <tag> Java </tag>
            
            <tag> JDK </tag>
            
            <tag> AIDE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android平台，C语言的运行</title>
      <link href="2021/09/09/android-ping-tai-c-yu-yan-de-yun-xing/"/>
      <url>2021/09/09/android-ping-tai-c-yu-yan-de-yun-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>都知道，在Windows,Linux,Mac等平台上，C语言程序的运行十分简单，但是在移动端上，比如Android系统上，就存在一些困难。本文就是为解决这一问题而生。</p><h1 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h1><p>我比较推荐，因为这个方法比较完善，C语言执行结果较好。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>需要运行如下C语言程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">  printf(&quot;HelloWorld!My C\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol><li><p>在Google Play或者其他应用商店下载Termux软件并安装。</p></li><li><p>打开Termux,执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><p>命令，没有出现storage字样，就必须</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">termux-setup-storage</span><br></pre></td></tr></table></figure><p>方便以后访问sdcard文件内容。</p></li><li><p>了解Termux软件的目录是~/storage/shared/，其下文件才是你在系统的文件管理器下看到的文件</p></li><li><p> 安装C语言编译程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg install clang</span><br></pre></td></tr></table></figure></li></ol><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>首先执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd storage&#x2F;shared&#x2F;</span><br></pre></td></tr></table></figure><p>接下来便可以执行你的C语言程序了。<br>我需要运行上述需求里的C语言代码，我需要新建一个文件夹（如myc文件夹），可以手动用文件管理器创建，也可以用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir myc</span><br></pre></td></tr></table></figure><p>打开新建的文件夹（我新建的是myc文件夹，所以我打开cd myc）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd myc</span><br></pre></td></tr></table></figure><p>下面可以手动或者命令新建一个以.c结尾的文件，（我创建一个ifirst.c）,用文本的方式打开，输入上述需求中的代码。保存后，就可以运行了。</p><h2 id="运行C"><a href="#运行C" class="headerlink" title="运行C"></a>运行C</h2><ol><li><p>可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o te ifirst.c</span><br></pre></td></tr></table></figure><p>编译ifirst.c文件，生成te文件，接着运行编译好了的te文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;te</span><br></pre></td></tr></table></figure><p>就可以看见程序输出HelloWorld!My C的结果了。</p></li><li><p>也可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang ifirst.c</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc ifirst.c</span><br></pre></td></tr></table></figure><p>两者效果一样<br>编译ifirst.c文件，生成a.out文件，接着运行编译好了的a.out文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;a.out</span><br></pre></td></tr></table></figure><p>也会得到HelloWorld!My C的结果</p></li></ol><h2 id="关于Permission-denied的错误处理"><a href="#关于Permission-denied的错误处理" class="headerlink" title="关于Permission denied的错误处理"></a>关于Permission denied的错误处理</h2><p>运行上述编译好了的文件te或者a.out有的会报错：Permission denied，建议按照如下方法处理。<br>原因是在sdcard目录没有运行的权限</p><ul><li><p>可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp  .&#x2F;te  ~&#x2F;te</span><br></pre></td></tr></table></figure><p>再运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~&#x2F;te</span><br></pre></td></tr></table></figure><p>结果变正常了</p></li><li><p>或者使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp  .&#x2F;a.out  ~&#x2F;a.out</span><br></pre></td></tr></table></figure><p>再运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~&#x2F;a.out</span><br></pre></td></tr></table></figure><p>也可以</p></li><li><p>使用脚本</p></li></ul><ol><li>下载runC文件:<a href="https://gitee.com/kuangtant/runC/repository/archive/master.zip">下载runC</a>，解压后将其中的runC文件复制到C语言程序目录<br>或者 在C语言程序目录<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O runC https:&#x2F;&#x2F;gitee.com&#x2F;kuangtant&#x2F;runC&#x2F;raw&#x2F;master&#x2F;runC</span><br></pre></td></tr></table></figure></li><li>将runC文件和你要运行的C语言程序放在一起，采用gcc 编译，我的是ifirst.c<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc ifirst.c</span><br></pre></td></tr></table></figure>生成a.out文件</li><li>最后，命令执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash runC</span><br></pre></td></tr></table></figure>就可以看到结果了</li></ol><h1 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h1><p>网络上的<a href="https://m.baidu.com/from=1023640y/s?word=:C%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E5%99%A8&ie=utf-8">C语言编译器</a>较多，可以下载使用，不过还是最推荐方案一;</p><p>由于这类产品的编译结果及原理各有千秋，所以，具体效果如何，就不一一推荐了。</p><h1 id="本文视频教程"><a href="#本文视频教程" class="headerlink" title="本文视频教程"></a>本文视频教程</h1><ol><li>优酷视频：<a href="https://v.youku.com/v_show/id_XNTgwNzg3MDQyOA==.html">https://v.youku.com/v_show/id_XNTgwNzg3MDQyOA==.html</a></li><li>腾讯视频：<a href="https://v.qq.com/x/page/y3277qnfm8s.html">https://v.qq.com/x/page/y3277qnfm8s.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Android </tag>
            
            <tag> 编译器 </tag>
            
            <tag> Termux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的详细配置</title>
      <link href="2021/09/02/git-de-xiang-xi-pei-zhi/"/>
      <url>2021/09/02/git-de-xiang-xi-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><p>安装好Git后，便可以进行配置了，后面就可以体验它的强大功能了。</p><h1 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h1><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><p> 我们要使用Git就必须登陆它，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &#39;用户名&#39;</span><br></pre></td></tr></table></figure><p>接着邮箱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &#39;xxxx@your.email&#39;</span><br></pre></td></tr></table></figure><p>这一配置是全局配置，任何项目都会用到其用户名和邮箱，因为配置了global。</p><h2 id="局部配置"><a href="#局部配置" class="headerlink" title="局部配置"></a>局部配置</h2><p>若想在某一项目不用该邮箱，用户名，只需要在该项目根目录重新执行命令，去掉–global就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config  user.name &#39;新用户名&#39;</span><br><span class="line">git config  user.email &#39;新邮箱&#39;</span><br></pre></td></tr></table></figure><p>简单来说，只是本项目使用了该新邮箱用户名，全局的配置没有变。</p><h1 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h1><h2 id="全部配置"><a href="#全部配置" class="headerlink" title="全部配置"></a>全部配置</h2><p>查看当前配置信息，可使用 git config –list 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><h2 id="特定配置"><a href="#特定配置" class="headerlink" title="特定配置"></a>特定配置</h2><p>可以输入git config <key>查看某一特定的配置：<br>如user.email.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config user.email</span><br></pre></td></tr></table></figure><h1 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h1><p>git默认采用的是vim,但是你也可以选择其他的编辑器，如emas，可以这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.editor emas</span><br></pre></td></tr></table></figure><p>对于 Notepad++，一个流行的代码编辑器来说，你可能想要使用 32 位的版本， 因为在本书编写时 64 位的版本尚不支持所有的插件。 如果你在使用 32 位的 Windows 系统，或在 64 位系统上使用 64 位的编辑器，那么你需要输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.editor &quot;&#39;C:&#x2F;Program Files&#x2F;Notepad++&#x2F;notepad++.exe&#39; -multiInst -notabbar -nosession -noPlugin&quot;</span><br></pre></td></tr></table></figure><h1 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h1><p>这个很重要，需要执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &#39;登录邮箱&#39;</span><br></pre></td></tr></table></figure><h1 id="获取密钥"><a href="#获取密钥" class="headerlink" title="获取密钥"></a>获取密钥</h1><p>上述命令执行完成后，在根目录的.ssh目录下会生成id-rsa.pub文件，在这个文件里就是密钥，用文本的方式打开，复制全部密钥。将其粘贴到<a href="https://www.gitee.com/">gitee</a>、<a href="https://www.github.com/">github</a>或者你的远程仓库服务端。</p><p>git服务端都有个人账户设置，进去找到ssh key的选项，粘贴到里面就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 配置 </tag>
            
            <tag> 密钥 </tag>
            
            <tag> 仓库 </tag>
            
            <tag> gitee </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各平台安装Git</title>
      <link href="2021/08/28/ge-ping-tai-an-zhuang-git/"/>
      <url>2021/08/28/ge-ping-tai-an-zhuang-git/</url>
      
        <content type="html"><![CDATA[<h1 id="git的简介"><a href="#git的简介" class="headerlink" title="git的简介"></a>git的简介</h1><p>git目前是世界上最先进的分布式版本控制系统，能够通过命令代码进行控制，支持对源码资源进行一系列的控制。</p><h1 id="git的安装"><a href="#git的安装" class="headerlink" title="git的安装"></a>git的安装</h1><h2 id="linux平台"><a href="#linux平台" class="headerlink" title="linux平台"></a>linux平台</h2><p>Linux可以使用一些安装包管理工具（如apt-get）进行安装，但Git需要安装curl、zlib、expat等依赖工具。</p><h3 id="Debian-Ubuntu安装"><a href="#Debian-Ubuntu安装" class="headerlink" title="Debian/Ubuntu安装"></a>Debian/Ubuntu安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \  libz-dev libssl-dev  #安装相关依赖包</span><br><span class="line"></span><br><span class="line">$ apt-get install git #安装Git</span><br><span class="line"></span><br><span class="line">$ git --version #检查Git版本</span><br><span class="line">git version 1.8.1.2 </span><br></pre></td></tr></table></figure><h3 id="Centos-RedHat安装"><a href="#Centos-RedHat安装" class="headerlink" title="Centos/RedHat安装"></a>Centos/RedHat安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ yum install curl-devel expat-devel gettext-devel \ openssl-devel zlib-devel #安装依赖</span><br><span class="line"></span><br><span class="line">$ yum -y install git-core #安装Git</span><br><span class="line"></span><br><span class="line">$ git --version #检查Git版本</span><br><span class="line">git version 1.7.1</span><br></pre></td></tr></table></figure><h2 id="windows平台"><a href="#windows平台" class="headerlink" title="windows平台"></a>windows平台</h2><p>在windows平台安装相对容易，可以从以下途径安装相应版本的Git</p><ul><li>渠道1： <a href="https://gitforwindows.org/">https://gitforwindows.org/</a></li><li>渠道2：淘宝镜像<br><a href="https://npm.taobao.org/mirrors/git-for-windows/">https://npm.taobao.org/mirrors/git-for-windows/</a><br>下载exe文件直接运行就可以安装完成</li></ul><h2 id="Mac平台"><a href="#Mac平台" class="headerlink" title="Mac平台"></a>Mac平台</h2><p>在Mac上，同样也是只需要手动下载安装即可<br><a href="http://sourceforge.net/projects/git-osx-installer/">http://sourceforge.net/projects/git-osx-installer/</a></p><h2 id="android平台"><a href="#android平台" class="headerlink" title="android平台"></a>android平台</h2><p>在安卓平台没有官方的git工具，但是第三方的软件却不少。</p><p>在这里比较推荐的是Termux软件，可以模拟Linux环境，进而安装Git。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg install git </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Git </tag>
            
            <tag> Windows </tag>
            
            <tag> gitee </tag>
            
            <tag> github </tag>
            
            <tag> 开源 </tag>
            
            <tag> 版本 </tag>
            
            <tag> Linux </tag>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 的进修史</title>
      <link href="2021/08/25/markdown-de-jin-xiu-shi/"/>
      <url>2021/08/25/markdown-de-jin-xiu-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown-的进修史"><a href="#Markdown-的进修史" class="headerlink" title="Markdown 的进修史 "></a>Markdown 的进修史 </h1><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>markdown是一种轻量级的标记语言，在中国各大平台普遍受欢迎，且其编辑的文档可简易的导出为HTML，Word，PDF等多种文档格式，很有学习的必要。</p></blockquote><p>Markdown的文档后缀为<kbd>.md</kbd>或<kbd>.markdown</kbd>。</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>Markdown常被用来编写各样的文本，电子书籍，不少网站的文章编辑都是使用的Markdown（<a href="https://jianshu.com/">简书</a>,<a href="https://github.com/">GitHub</a>…）以及一些论坛，很多的评论区，都支持Markdown。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>Markdown编辑器有很多，可自行百度：<a href="https://www.baidu.com/s?ie=UTF-8&wd=Mark%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7">Markdown编辑工具</a></p><p>常见的Markdown编辑工具</p><ul><li>Typora 编辑器 </li></ul><blockquote><p>官网下载：<a href="https://typora.io/">https://typora.io</a> </p><p>Typora 支持 MacOS 、Windows、Linux 平台，且包含多种主题，编辑后直接渲染出效果。支持导出HTML、PDF、Word、图片等多种类型文件。</p></blockquote><ul><li><p>Quiver</p><blockquote><p>官网下载：<a href="https://happenapps.com/">https://happenapps.com</a></p><p>Quiver似乎是为程序猿准备的Markdown编辑器，可在其内轻松渲染代码和公式，具有丰富的程序员样式，自动保存，自动备份。（本文用该工具）</p></blockquote></li><li><p>在线编辑器</p><blockquote><ol><li>在线工具：<a href="https://tool.lu/markdown/">https://tool.lu/markdown/</a></li><li>小书匠：<a href="http://markdown.xiaoshujiang.com/">http://markdown.xiaoshujiang.com/</a></li><li>Dillinger：<a href="https://dillinger.io/">https://dillinger.io/</a></li><li>孟坤工具：<a href="http://tool.mkblog.cn/markdown/">http://tool.mkblog.cn/markdown/</a></li></ol></blockquote></li></ul><p>由于这类工具还有很多就不一一列举，可参照 <a href="https://www.jianshu.com/p/758946877823">十大markdown编辑器</a>，找到最适合自己的那款。</p><h2 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h2><p>《了不起的Markdown》</p><h1 id="教程开始"><a href="#教程开始" class="headerlink" title="教程开始"></a>教程开始</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><ol><li><p>标题是文档的开始，Markdown用<kbd>=</kbd>和<kbd>-</kbd>来标记一级和二级标题。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一级标题</span><br><span class="line">=======</span><br><span class="line">二级标题</span><br><span class="line">-------</span><br></pre></td></tr></table></figure></li></ol><p>​      结果：</p><p><img src="" alt="标题演示"></p><ol start="2"><li><p>还可使用<kbd>#</kbd>标记</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#  一级标题</span></span><br><span class="line"><span class="section">##  二级标题</span></span><br><span class="line"><span class="section">###  三级标题</span></span><br><span class="line"><span class="section">####  四级标题</span></span><br><span class="line"><span class="section">#####  五级标题</span></span><br><span class="line"><span class="section">######  六级标题</span></span><br></pre></td></tr></table></figure></li></ol><p>​    结果：</p><p><img src="" alt="标题演示"></p><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><ol><li><p>直接形式，编辑好文字，文字后加上<kbd> </kbd><kbd> </kbd>两个空格，在一个<kbd>回车</kbd>键。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我是文字  </span><br><span class="line">我是文字  </span><br></pre></td></tr></table></figure></li></ol><p>2.也可以使用空行表示新段落。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我是文字</span><br><span class="line"></span><br><span class="line">我是文字</span><br></pre></td></tr></table></figure><ol start="3"><li><p>字体有 斜体，粗体，斜体粗体</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*斜体文本*</span></span><br><span class="line"><span class="emphasis">_斜体文本_</span></span><br><span class="line"><span class="strong">**粗体文本**</span></span><br><span class="line"><span class="strong">__粗体文本__</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*粗斜体文本<span class="strong">**<span class="emphasis">*</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong">__<span class="emphasis">_粗斜体文本<span class="strong">__<span class="emphasis">_</span></span></span></span></span></span></span></span></span><br></pre></td></tr></table></figure></li><li><p>分割线</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="strong"><span class="emphasis"></span></span></span><br><span class="line"><span class="strong"><span class="emphasis">*</span> <span class="emphasis">* *</span></span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">**</span><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="strong"><span class="emphasis"></span></span></span><br><span class="line"><span class="strong"><span class="emphasis">- - -</span></span></span><br><span class="line"><span class="strong"><span class="emphasis"></span></span></span><br><span class="line"><span class="strong"><span class="emphasis">----------</span></span></span><br></pre></td></tr></table></figure></li><li><p>下划线</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>带下划线文本<span class="xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>删除线</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文本文本</span><br><span class="line">~~文本文本~~</span><br></pre></td></tr></table></figure></li><li><p>脚注，<kbd>[^要注明的文本]</kbd></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建脚注格式类似这样 [^hi kuangtant]。</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^hi kuangtant</span>]: <span class="link">你好，kuangtant！</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> Typora </tag>
            
            <tag> Markdown编辑器 </tag>
            
            <tag> Quiver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 发射！！！</title>
      <link href="2021/08/25/hexo-fa-she/"/>
      <url>2021/08/25/hexo-fa-she/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-发射"><a href="#hexo-发射" class="headerlink" title="hexo 发射"></a>hexo 发射</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>随着互联网高速的发展，网络文本信息已经充斥着我们的生活，我们每天也有许多个人或者团体的经验、技术、图像等信息需要被互联网记录，以求共享，在技术博客方面，hexo是一个好的选择，是一个快速、简洁且高效的博客框架。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li> 超快速度。Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。</li><li> 支持 Markdown。Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合Octopress 的大多数插件。</li><li>一键部署。只需一条指令即可部署到 Gitee，GitHub Pages，Heroku 或其他平台。</li><li>插件和可扩展性。强大的 API 带来无限的可能，与数种模板引擎（EJS，Pug，Nunjucks）和工具（Babel，PostCSS，Less/Sass）轻易集成。</li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="下载并安装node-js"><a href="#下载并安装node-js" class="headerlink" title="下载并安装node.js"></a>下载并安装node.js</h3><ol><li>下载地址<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></li><li>安装验证<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>到这里，node环境配置完成。</li></ol><h3 id="加速nodejs下载"><a href="#加速nodejs下载" class="headerlink" title="加速nodejs下载"></a>加速nodejs下载</h3><p>为了避免使用nodejs过程中的下载速度（卡顿，无反应）问题，建议使用淘宝镜像服务（不必须）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>用以下命令安装hexo（全局安装）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><p>安装完成后，可以检查一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="建立hexo博客"><a href="#建立hexo博客" class="headerlink" title="建立hexo博客"></a>建立hexo博客</h3><p>选择打开一个你想建立hexo博客文件的目录，必须是空的文件夹，或者新建一个（以myblog文件夹为例）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir myblog</span><br></pre></td></tr></table></figure><p>然后打开它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd myblog</span><br></pre></td></tr></table></figure><h3 id="开始建立"><a href="#开始建立" class="headerlink" title="开始建立"></a>开始建立</h3><p>输入初始化命令进行初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><h3 id="建立完成"><a href="#建立完成" class="headerlink" title="建立完成"></a>建立完成</h3><p>初始化完成后，你会得到hexo的目录</p><ul><li>node_modules: node的依赖包</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：存放主题（后期扩展主题）</li></ul><p>和一些配置文件</p><ul><li>config.yml</li><li>.gitignore</li><li>package.json</li></ul><p>到这里，初始化完成</p><h2 id="Hexo基本配置"><a href="#Hexo基本配置" class="headerlink" title="Hexo基本配置"></a>Hexo基本配置</h2><p>对hexo博客网站的名称，作者，站点链接，都在hexo根目录的config.yml文件中设置。</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">title</td><td align="center">网站标题</td></tr><tr><td align="center">subtitle</td><td align="center">网站副标题</td></tr><tr><td align="center">description</td><td align="center">网站描述</td></tr><tr><td align="center">keywords</td><td align="center">网站的关键词。支持多个关键词。</td></tr><tr><td align="center">author</td><td align="center">您的名字</td></tr><tr><td align="center">language</td><td align="center">网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans和 zh-CN。</td></tr><tr><td align="center">timezone</td><td align="center">网站时区。Hexo 默认使用您电脑的时区。如 America/New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia/Shanghai。</td></tr></tbody></table><p>其余参考<a href="https://hexo.io/zh-cn/docs/configuration">hexo 官方配置</a></p><h2 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h2><p>用hexo写文章，用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &quot;hello my first blog post&quot;</span><br></pre></td></tr></table></figure><p>新建一个标题为：hello my first blog post的博客文章。在目录source/_post/下可以看见你新建的博客文章。hello-my-first-blog-post.md这个文件就是你需要编辑的。可以用支持markdown的编辑进行编辑。</p><h2 id="生成博客文章"><a href="#生成博客文章" class="headerlink" title="生成博客文章"></a>生成博客文章</h2><p>当一些文章编辑好了，或者本地文件设置好了，就可以更新你的文章了，可以先用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p>生成本地HTML格式的博客文件，进行本地浏览或上传发布。</p><h2 id="本地浏览"><a href="#本地浏览" class="headerlink" title="本地浏览"></a>本地浏览</h2><p>有了HTML文件，我们可以浏览</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>就可以在浏览器输入<a href="http://localhost:4000/">http://localhost:4000</a> 进行浏览你的博客。Ctrl +C可以停止浏览。</p><h2 id="上传发布"><a href="#上传发布" class="headerlink" title="上传发布"></a>上传发布</h2><p>当一切准备就绪，我们就可以发布到网上去了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>然后就可以打开你的博客主页浏览了。</p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>一个受欢迎的博客除了和其内容有关，还和其漂亮程度有关。所以，hexo支持主题的拓展。<br>hexo 官方提供了许多的主题</p><p><a href="https://hexo.io/themes/">https://hexo.io/themes/</a><br>点击下载</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li><p>安装hexo的前提是需要有node的环境，如果没有node的环境需要先下载安装一下。官网推荐的node的版本是不低于8.10</p></li><li><p>使用hexo deploy 出现错误时，可能你没有安装hexo-deployer-git插件，应该执行命令安装它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>使用hexo，还需要正确配置好git. </p><ul><li>在仓库的官网新建一个和你用户名一样名字的仓库。</li><li>安装好git<br>命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;你的邮箱&quot;</span><br><span class="line">git config --global user.name &quot;你的用户名&quot;</span><br></pre></td></tr></table></figure>更多git有关的教程，请自行百度<a href="https://baidu.com/s?word=git">https://www.baidu.com</a><br>。</li></ul></li><li><p>更多有关hexo的教程，请关注<a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
